<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<title>ReelQuest</title>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<style>
    :root {
      /* Dark theme defaults */
      --bg: #020617;
      --bg-elevated: #111827;
      --bg-soft: #151925;
      --accent-pill-bg: #f9fafb;
      --accent-pill-text: #111827;
      --border-subtle: #1f2937;
      --text-main: #f9fafb;
      --text-muted: #9ca3af;
      --text-softer: #6b7280;
      --shadow-soft: 0 18px 40px rgba(0, 0, 0, 0.55);
    }

    body.theme-light {
      --bg: #f3f4f6;
      --bg-elevated: #ffffff;
      --bg-soft: #e5e7eb;
      --accent-pill-bg: #111827;
      --accent-pill-text: #f9fafb;
      --border-subtle: #d1d5db;
      --text-main: #0f172a;
      --text-muted: #6b7280;
      --text-softer: #9ca3af;
      --shadow-soft: 0 18px 40px rgba(15, 23, 42, 0.25);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text-main);
      min-height: 100vh;
      display: flex;
      align-items: stretch;
      justify-content: center;
      padding: 16px;
      transition: background 0.18s ease, color 0.18s ease;
    }

    .app {
      width: 100%;
      max-width: 1100px;
      background: var(--bg);
      border-radius: 24px;
      border: 1px solid rgba(15, 23, 42, 0.5);
      box-shadow: var(--shadow-soft);
      padding: 16px 16px 20px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      transition: background 0.18s ease, border-color 0.18s ease,
        box-shadow 0.18s ease;
    }

    /* Top bar */

    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .brand-mark {
      width: 28px;
      height: 28px;
      border-radius: 9px;
      border: 2px solid var(--accent-pill-bg);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .brand-mark-inner {
      width: 16px;
      height: 16px;
      border-radius: 5px;
      background: var(--accent-pill-bg);
    }

    .brand-text {
      font-size: 18px;
      font-weight: 600;
      letter-spacing: 0.04em;
    }

    .brand-home{
      background: transparent;
      border: 0;
      padding: 0;
      color: inherit;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }
    .brand-home:focus-visible{
      outline: 2px solid var(--accent-pill-bg);
      outline-offset: 4px;
      border-radius: 14px;
    }


    .topbar-actions {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-left: auto;
    }

    .theme-toggle {
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg-elevated);
      color: var(--text-main);
      cursor: pointer;
      font-size: 16px;
      padding: 0;
      transition: background 0.15s ease, border-color 0.15s ease,
        transform 0.08s ease, box-shadow 0.15s ease;
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.35);
    }

    .theme-toggle:active {
      transform: translateY(1px) scale(0.97);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
    }

    /* Tabs */

    .tabs {
      display: flex;
      gap: 10px;
      margin-top: 8px;
      align-items: center;
      overflow-x: auto;
      padding-bottom: 4px;
    }

    .tab-btn {
      flex: 0 0 auto;
      padding: 8px 16px;
      border-radius: 999px;
      border: none;
      background: transparent;
      color: var(--text-muted);
      font-size: 13px;
      cursor: pointer;
      transition: background 0.15s ease, color 0.15s ease,
        box-shadow 0.15s ease, transform 0.08s ease;
      white-space: nowrap;
    }

    .tab-btn.active {
      background: var(--accent-pill-bg);
      color: var(--accent-pill-text);
      box-shadow: 0 8px 24px rgba(15, 23, 42, 0.4);
      transform: translateY(-1px);
    }

    .tab-btn-icon {
      margin-left: auto;
      padding: 8px 10px;
      width: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
    }

    /* Section header */

    .section-header {
      margin-top: 4px;
    }

    .section-title {
      font-size: 26px;
      line-height: 1.25;
      font-weight: 600;
      letter-spacing: 0.01em;
    }

    .section-subtitle {
      margin-top: 4px;
      font-size: 14px;
      color: var(--text-softer);
    }

    /* Search */

    .search-form {
      margin-top: 14px;
    }

    .search-wrapper {
      position: relative;
    }

    .search-input {
      width: 100%;
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      background: var(--bg);
      padding: 10px 14px 10px 34px;
      font-size: 14px;
      color: var(--text-main);
      outline: none;
      transition: border-color 0.15s ease, box-shadow 0.15s ease,
        background 0.15s ease;
    }

    .search-input::placeholder {
      color: var(--text-muted);
    }

    .search-input:focus {
      border-color: var(--accent-pill-bg);
      box-shadow: 0 0 0 1px rgba(148, 163, 184, 0.9);
      background: var(--bg);
    }

    .search-icon {
      position: absolute;
      left: 12px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      color: var(--text-muted);
      pointer-events: none;
    }


/* Tag autocomplete */

.tag-ac-wrap {
  position: relative;
  flex: 1 1 220px;
  min-width: 220px;
}

.tag-suggest {
  position: absolute;
  left: 0;
  right: 0;
  top: calc(100% + 6px);
  background: var(--bg-elevated);
  border: 1px solid var(--border-subtle);
  border-radius: 14px;
  box-shadow: var(--shadow-soft);
  padding: 6px;
  z-index: 80;
  max-height: 200px;
  overflow: auto;
  display: none;
}

.tag-suggest-item {
  padding: 8px 10px;
  border-radius: 10px;
  cursor: pointer;
  font-size: 13px;
  color: var(--text-main);
  user-select: none;
}

.tag-suggest-item:hover,
.tag-suggest-item.active {
  background: var(--bg-soft);
}

    /* Controls bar */

    .controls-bar {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      justify-content: space-between;
      font-size: 12px;
      color: var(--text-muted);
    }

    .controls-group {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .controls-label {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .controls-select {
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      background: var(--bg-elevated);
      color: var(--text-main);
      font-size: 12px;
      padding: 4px 10px;
      outline: none;
    }

    .list-actions {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    .pill-btn {
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      background: var(--bg-elevated);
      color: var(--text-main);
      font-size: 11px;
      padding: 5px 10px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      transition: background 0.15s ease, border-color 0.15s ease,
        transform 0.08s ease, box-shadow 0.15s ease;
    }

    .pill-btn:hover {
      box-shadow: 0 6px 14px rgba(0, 0, 0, 0.35);
      transform: translateY(-1px);
    }

    .pill-btn:active {
      transform: translateY(1px) scale(0.97);
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.35);
    }

    /* Message */

    .message {
      margin-top: 10px;
      font-size: 13px;
      color: var(--text-muted);
      min-height: 18px;
    }

    /* Grid & cards */

    .grid {
      margin-top: 14px;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 14px;
    }

    @media (min-width: 768px) {
      .grid {
        grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      }
    }

    .movie-card {
      background: var(--bg-elevated);
      border-radius: 18px;
      padding: 6px 6px 10px;
      border: 1px solid rgba(15, 23, 42, 0.4);
      display: flex;
      flex-direction: column;
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.55);
      cursor: default;
      transition: transform 0.12s ease, box-shadow 0.12s ease,
        border-color 0.12s ease, background 0.12s ease;
    }

    .movie-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 16px 30px rgba(0, 0, 0, 0.65);
    }

    .poster-wrapper {
      position: relative;
      border-radius: 14px;
      overflow: hidden;
      background: #020617;
      aspect-ratio: 2 / 3;
      cursor: pointer;
    }

    body.theme-light .poster-wrapper {
      background: #111827;
    }

    .poster-img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .poster-fallback {
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at top, #1f2937 0, #020617 65%);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      color: var(--text-muted);
    }

    body.theme-light .poster-fallback {
      background: radial-gradient(circle at top, #cbd5f5 0, #020617 65%);
    }

    .rating-pill {
      position: absolute;
      left: 8px;
      top: 8px;
      padding: 3px 8px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.9);
      color: #fde68a;
      font-size: 11px;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .rating-pill span {
      color: var(--text-main);
    }

    .poster-actions {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 8px;
      display: flex;
      justify-content: center;
      gap: 10px;
      pointer-events: none;
    }

    .card-btn {
      border-radius: 999px;
      border: none;
      width: 34px;
      height: 34px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      cursor: pointer;
      background: rgba(15, 23, 42, 0.85);
      color: var(--text-main);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(12px);
      transition: background 0.15s ease, transform 0.08s ease,
        box-shadow 0.15s ease, color 0.15s ease, opacity 0.15s ease;
      pointer-events: auto;
    }

    .card-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 26px rgba(0, 0, 0, 0.9);
    }

    .card-btn:active {
      transform: translateY(1px) scale(0.97);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.9);
    }

    .card-btn.active {
      background: var(--accent-pill-bg);
      color: var(--accent-pill-text);
    }

    .movie-title-line {
      margin-top: 8px;
      font-size: 13px;
      font-weight: 500;
      color: var(--text-main);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .movie-subline {
      margin-top: 2px;
      font-size: 11px;
      color: var(--text-muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Settings */

    .settings-panel {
      margin-top: 18px;
      padding: 14px 14px 16px;
      border-radius: 18px;
      background: var(--bg-elevated);
      border: 1px solid var(--border-subtle);
      display: none;
    }

    .settings-heading {
      font-size: 16px;
      font-weight: 500;
      margin-bottom: 4px;
    }

    .settings-copy {
      font-size: 13px;
      color: var(--text-softer);
      margin-bottom: 12px;
    }

    .settings-subheading {
      font-size: 13px;
      font-weight: 500;
      margin-bottom: 6px;
      color: var(--text-main);
    }

    .genre-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .genre-pill {
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      padding: 6px 12px;
      font-size: 12px;
      background: var(--bg);
      color: var(--text-muted);
      cursor: pointer;
      transition: background 0.15s ease, color 0.15s ease,
        border-color 0.15s ease, transform 0.08s ease, box-shadow 0.15s ease;
    }

    .genre-pill.active {
      background: var(--accent-pill-bg);
      color: var(--accent-pill-text);
      border-color: var(--accent-pill-bg);
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.6);
      transform: translateY(-1px);
    }

    /* Detail overlay */

    .detail-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.65);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
      z-index: 40;
      backdrop-filter: blur(4px);
    }

    .detail-overlay.hidden {
      display: none;
    }

    .detail-panel {
      max-width: 720px;
      width: 100%;
      max-height: 90vh;
      background: var(--bg-elevated);
      border-radius: 24px;
      padding: 16px 16px 18px;
      border: 1px solid var(--border-subtle);
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.8);
      display: flex;
      flex-direction: column;
      gap: 10px;
      overflow: hidden;
    }

    .detail-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 6px;
    }

    .detail-title-block {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .detail-title {
      font-size: 18px;
      font-weight: 600;
    }

    .detail-meta {
      font-size: 12px;
      color: var(--text-softer);
    }

    .detail-close {
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg);
      color: var(--text-muted);
      font-size: 16px;
      cursor: pointer;
      flex-shrink: 0;
    }

    .detail-body {
      display: flex;
      gap: 12px;
      margin-top: 6px;
      overflow-y: auto;
    }

    .detail-poster {
      flex: 0 0 120px;
      border-radius: 12px;
      overflow: hidden;
      background: #020617;
    }

    body.theme-light .detail-poster {
      background: #111827;
    }

    .detail-poster img {
      width: 100%;
      height: auto;
      display: block;
    }

    .detail-main {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 13px;
    }

    .detail-overview {
      color: var(--text-main);
      line-height: 1.4;
    }

    .detail-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 4px;
    }

    .detail-chip {
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      padding: 3px 8px;
      font-size: 11px;
      color: var(--text-muted);
    }

    .detail-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 4px;
    }

    .detail-link {
      font-size: 12px;
      color: #60a5fa;
      text-decoration: none;
    }

    .detail-link:hover {
      text-decoration: underline;
    }

    @media (max-width: 640px) {
      .detail-body {
        flex-direction: column;
      }
      .detail-poster {
        flex: 0 0 auto;
        align-self: flex-start;
      }
    }

    /* Debug footer */

    .debug {
      margin-top: 8px;
      font-size: 11px;
      color: var(--text-muted);
      opacity: 0.7;
      min-height: 14px;
    }
  
    /* Burger menu behaviour */
    .burger-btn { 
      display: none; 
      font-size: 18px; 
      width: 36px;
    }

    /* On small screens, hide the tab row and use the burger menu instead */
    @media (max-width: 520px) {
      .tabs { display: none; }
      .burger-btn { display: flex; }
    }

    /* Burger menu overlay */
    .menu-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.65);
      display: flex;
      align-items: flex-start;
      justify-content: flex-end;
      padding: 14px;
      z-index: 50;
      backdrop-filter: blur(4px);
    }

    .menu-overlay.hidden { display: none; }

    .menu-panel {
      width: min(360px, 92vw);
      background: var(--bg-elevated);
      border-radius: 18px;
      border: 1px solid var(--border-subtle);
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.8);
      overflow: hidden;
    }

    .menu-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 12px 10px;
      border-bottom: 1px solid var(--border-subtle);
    }

    .menu-title {
      font-size: 14px;
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    .menu-items {
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 10px 10px 12px;
    }

    .menu-item {
      width: 100%;
      text-align: left;
      border-radius: 14px;
      border: 1px solid var(--border-subtle);
      background: var(--bg);
      color: var(--text-main);
      padding: 10px 12px;
      font-size: 14px;
      cursor: pointer;
      transition: transform 0.08s ease, box-shadow 0.15s ease, background 0.15s ease;
    }

    .menu-item:active { transform: translateY(1px) scale(0.99); }

    .menu-item.active {
      background: var(--accent-pill-bg);
      color: var(--accent-pill-text);
      border-color: var(--accent-pill-bg);
      box-shadow: 0 10px 22px rgba(0, 0, 0, 0.6);
    }

  
    
    .menu-section {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--border-subtle);
    }
    .menu-subtitle {
      font-size: 12px;
      opacity: 0.75;
      padding: 0 2px 8px 2px;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }
    .menu-pinned-items {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .menu-pinned-item {
      width: 100%;
      text-align: left;
      border-radius: 14px;
      border: 1px solid var(--border-subtle);
      background: var(--bg);
      color: var(--text-main);
      padding: 10px 12px;
      font-size: 13px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      transition: transform 0.08s ease, box-shadow 0.15s ease, background 0.15s ease;
    }
    .menu-pinned-item:active { transform: translateY(1px) scale(0.99); }
    .menu-pinned-item .name {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      min-width: 0;
    }
    .menu-pinned-item .chev { opacity: 0.7; }


    /* Hidden file input (must not be display:none on iOS) */
    .file-input-hidden {
      position: fixed;
      left: -9999px;
      top: -9999px;
      width: 1px;
      height: 1px;
      opacity: 0;
      pointer-events: none;
    }

  
    /* Lists */
    .list-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 10px;
      border: 1px solid var(--border-subtle);
      border-radius: 16px;
      background: var(--bg);
      margin-top: 10px;
    }

    .list-left {
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 0;
      flex: 1 1 auto;
    }

    .list-row.reorderable {
      touch-action: none;
    }

    .list-drag-handle {
      width: 32px;
      height: 32px;
      border-radius: 12px;
      border: 1px solid var(--border-subtle);
      background: var(--chip-bg);
      color: var(--text-muted);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: grab;
      user-select: none;
      flex: 0 0 auto;
    }
    .list-drag-handle:active { cursor: grabbing; transform: translateY(1px); }

    .list-row.dragging {
      opacity: 0.75;
      outline: 1px dashed var(--border-subtle);
    }

    .list-cover {
      width: 44px;
      height: 44px;
      border-radius: 12px;
      border: 1px solid var(--border-subtle);
      overflow: hidden;
      background: var(--bg-elevated);
      flex: 0 0 auto;
      display: grid;
      grid-template-columns: 1fr 1fr;
      grid-template-rows: 1fr 1fr;
      gap: 1px;
    }

    .list-cover img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .list-text {
      display: flex;
      flex-direction: column;
      gap: 3px;
      min-width: 0;
    }

    .list-name {
      font-size: 13px;
      font-weight: 700;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .list-desc {
      font-size: 12px;
      color: var(--text-muted);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 60vw;
    }

    .list-meta {
      font-size: 12px;
      color: var(--text-muted);
    }

    .list-actions {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: flex-end;
      flex: 0 0 auto;
    }

    .pin-btn {
      width: 34px;
      justify-content: center;
      padding: 8px 0;
    }

    .reorder-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 12px;
    }

    .reorder-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 10px;
      border: 1px solid var(--border-subtle);
      border-radius: 16px;
      background: var(--bg);
    }

    .reorder-title {
      font-size: 13px;
      font-weight: 600;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 58vw;
    }

    .reorder-controls {
      display: flex;
      gap: 6px;
      flex-wrap: nowrap;
    }

  .pill-btn.active {
  border-color: var(--accent);
  box-shadow: 0 0 0 2px rgba(125, 211, 252, 0.18);
}
  

/* UX polish */
:root { --radius-lg: 20px; --radius-md: 16px; --radius-sm: 12px; }

.app-shell {
  padding-bottom: calc(18px + env(safe-area-inset-bottom, 0px));
}

/* Toasts */
#toast-host {
  position: fixed;
  left: 0;
  right: 0;
  bottom: calc(12px + env(safe-area-inset-bottom, 0px));
  display: flex;
  flex-direction: column;
  gap: 10px;
  align-items: center;
  pointer-events: none;
  z-index: 9999;
  padding: 0 14px;
}

.toast {
  width: min(520px, 100%);
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  padding: 12px 14px;
  border-radius: 18px;
  border: 1px solid var(--border-subtle);
  background: rgba(20, 22, 28, 0.78);
  backdrop-filter: blur(14px);
  -webkit-backdrop-filter: blur(14px);
  box-shadow: 0 18px 40px rgba(0,0,0,0.35);
  color: var(--text);
  pointer-events: auto;
  transform: translateY(10px);
  opacity: 0;
  animation: toastIn 160ms ease-out forwards;
}

.toast.toast-light {
  background: rgba(255, 255, 255, 0.78);
  color: #0b1220;
}

.toast-msg {
  font-size: 13px;
  line-height: 1.2;
  flex: 1 1 auto;
}

.toast-actions {
  display: flex;
  gap: 8px;
  flex: 0 0 auto;
  align-items: center;
}

.toast-btn {
  border: 1px solid var(--border-subtle);
  border-radius: 14px;
  padding: 7px 10px;
  background: transparent;
  color: inherit;
  font-size: 12px;
  font-weight: 700;
  cursor: pointer;
}

.toast-btn:hover { border-color: rgba(255,255,255,0.22); }

@keyframes toastIn {
  to { transform: translateY(0); opacity: 1; }
}

@keyframes toastOut {
  to { transform: translateY(10px); opacity: 0; }
}

/* Skeleton cards */
.skeleton-card {
  border-radius: var(--radius-lg);
  border: 1px solid var(--border-subtle);
  background: var(--bg-elevated);
  overflow: hidden;
  position: relative;
  min-height: 270px;
}

.skeleton-thumb {
  width: 100%;
  aspect-ratio: 2/3;
  background: rgba(255,255,255,0.06);
}

.skeleton-lines {
  padding: 10px 12px 12px 12px;
  display: grid;
  gap: 8px;
}

.skeleton-line {
  height: 12px;
  border-radius: 10px;
  background: rgba(255,255,255,0.08);
}

.skeleton-line.short { width: 68%; }
.skeleton-line.tiny { width: 48%; }

.shimmer::after {
  content: "";
  position: absolute;
  inset: 0;
  transform: translateX(-60%);
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.10), transparent);
  animation: shimmer 1.1s ease-in-out infinite;
}

@keyframes shimmer {
  0% { transform: translateX(-60%); }
  100% { transform: translateX(60%); }
}

/* Detail sections */
.detail-card {
  width: 100%;
  display: block;
  border: 1px solid var(--border-subtle);
  border-radius: 18px;
  background: var(--bg-elevated);
  padding: 12px;
  margin-top: 12px;
}

.detail-kicker {
  font-size: 12px;
  font-weight: 800;
  color: var(--text-muted);
  letter-spacing: 0.02em;
  text-transform: none;
  margin-bottom: 10px;
}

.organise-grid {
  display: grid;
  gap: 10px;
  grid-template-columns: 1fr;
}

@media (min-width: 860px) {
  .organise-grid { grid-template-columns: 1fr 1fr; }
}

.organise-row {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  align-items: center;
}

.organise-field label {
  display: block;
  font-size: 12px;
  color: var(--text-muted);
  margin-bottom: 6px;
  font-weight: 700;
}

.organise-field .search-input,
.organise-field .settings-textarea {
  margin: 0;
}

/* Micro-interactions */
.pill-btn, .card-btn, .tab-btn, .menu-item {
  transition: transform 100ms ease, filter 100ms ease, border-color 120ms ease;
}

.pill-btn:active, .card-btn:active, .tab-btn:active, .menu-item:active {
  transform: scale(0.98);
  filter: brightness(1.06);
}

.movie-card { animation: fadeIn 140ms ease-out; }
@keyframes fadeIn { from { opacity: 0; transform: translateY(6px);} to {opacity:1; transform:none;} }

@media (prefers-reduced-motion: reduce) {
  .movie-card, .toast, .shimmer::after { animation: none !important; }
  .pill-btn, .card-btn, .tab-btn, .menu-item { transition: none !important; }
}
  

/* Bulk selection */
.movie-card.selectable { position: relative; }
.select-badge {
  position: absolute;
  top: 10px;
  left: 10px;
  width: 26px;
  height: 26px;
  border-radius: 999px;
  border: 1px solid var(--border-subtle);
  background: rgba(20,22,28,0.72);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  display: grid;
  place-items: center;
  z-index: 2;
  pointer-events: none;
}
.select-badge::before {
  content: "";
  width: 12px;
  height: 12px;
  border-radius: 4px;
  border: 2px solid rgba(255,255,255,0.65);
  background: transparent;
  display: block;
}
.movie-card.selected .select-badge::before {
  background: var(--accent);
  border-color: var(--accent);
  box-shadow: 0 0 0 2px rgba(125, 211, 252, 0.18);
}
.movie-card.selected {
  outline: 2px solid rgba(125, 211, 252, 0.55);
  outline-offset: 2px;
}
.bulk-bar {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  align-items: center;
  margin-top: 10px;
}
.bulk-count {
  font-size: 12px;
  color: var(--text-muted);
  font-weight: 800;
  margin-right: 6px;
}

/* List picker modal */
.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.55);
  display: flex;
  align-items: flex-end;
  justify-content: center;
  padding: 14px;
  z-index: 9998;
}
.modal-sheet {
  width: min(640px, 100%);
  border-radius: 22px;
  border: 1px solid var(--border-subtle);
  background: rgba(20, 22, 28, 0.86);
  backdrop-filter: blur(18px);
  -webkit-backdrop-filter: blur(18px);
  box-shadow: 0 22px 60px rgba(0,0,0,0.45);
  overflow: hidden;
}
.modal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
  padding: 12px 14px;
  border-bottom: 1px solid var(--border-subtle);
}
.modal-title { font-size: 14px; font-weight: 900; color: var(--text); }
.modal-body { padding: 12px 14px 14px 14px; display: grid; gap: 10px; }
.modal-list { display: grid; gap: 10px; max-height: 50vh; overflow: auto; padding-right: 4px; }
.modal-row {
  display: flex; align-items: center; justify-content: space-between; gap: 10px;
  border: 1px solid var(--border-subtle);
  border-radius: 16px;
  padding: 10px 12px;
  background: rgba(255,255,255,0.03);
}
.modal-row strong { font-size: 13px; }
.modal-row small { color: var(--text-muted); font-size: 12px; }
.modal-actions { display: flex; gap: 10px; flex-wrap: wrap; }
  
.type-pill {
  position: absolute;
  top: 10px;
  right: 10px;
  padding: 6px 10px;
  border-radius: 999px;
  font-size: 11px;
  font-weight: 900;
  letter-spacing: 0.02em;
  border: 1px solid var(--border-subtle);
  background: rgba(20,22,28,0.78);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  z-index: 2;
}


/* Watch progress status (Watchlist reality check) */
.status-pill{
  position:absolute;
  left:10px;
  bottom:10px;
  padding:4px 8px;
  border-radius:999px;
  font-size:11px;
  font-weight:800;
  letter-spacing:0.2px;
  background:rgba(15,23,42,0.85);
  border:1px solid rgba(148,163,184,0.35);
  color:var(--text);
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
  pointer-events:none;
  z-index:2;
}

  

    /* Sticky header + internal scrolling (so only lists scroll) */
    body {
      height: 100dvh;
      overflow: hidden;
    }

    .app {
      height: 100%;
      max-height: 100%;
      overflow: hidden;
    }

    .app > main {
      flex: 1 1 auto;
      min-height: 0;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior: contain;
    }

    .pagehead {
      position: sticky;
      top: 0;
      z-index: 50;
      background: var(--bg);
      padding-top: 6px;
      padding-bottom: 10px;
      border-bottom: 1px solid rgba(148, 163, 184, 0.18);
      box-shadow: 0 12px 28px rgba(0, 0, 0, 0.22);
      backdrop-filter: blur(10px);
    }

    /* Make sure the sticky header doesn't look cramped on small screens */
    @media (max-width: 520px) {
      .pagehead {
        padding-top: 8px;
        padding-bottom: 12px;
      }
    }
</style>
<link href="./manifest.webmanifest" rel="manifest"/>
<meta content="#0b1220" name="theme-color"/>
<link href="./icon-192.png" rel="apple-touch-icon"/>
<link href="./icon-192.png" rel="icon"/>
<meta content="yes" name="apple-mobile-web-app-capable"/>
</head>
<body>
<div class="app">
<header class="topbar">
<button aria-label="Go to For You" class="brand brand-home" id="brand-home" type="button">
<div aria-hidden="true" class="brand-mark">
<div class="brand-mark-inner"></div>
</div>
<div class="brand-text">ReelQuest</div>
</button>
<div class="topbar-actions">
<button aria-label="Menu" class="theme-toggle burger-btn" id="menu-toggle" type="button">
          ‚ò∞
        </button>
<button aria-label="Settings" class="theme-toggle" id="settings-toggle" type="button">
          ‚öôÔ∏é
        </button>
<button aria-label="Toggle theme" class="theme-toggle" id="theme-toggle" type="button">
          ‚òæ
        </button>
</div>
</header>
<nav class="tabs">
<button class="tab-btn active" data-tab="for-you">For You</button>
<button class="tab-btn" data-tab="discover">Discover</button>
<button class="tab-btn" data-tab="radar">Radar</button>
<button class="tab-btn" data-tab="watchlist">Watchlist</button>
<button class="tab-btn" data-tab="watched">Watched</button>
<button class="tab-btn" data-tab="rewatch">Rewatch</button>
<button class="tab-btn" data-tab="lists">Lists</button>
</nav>
<main><div class="pagehead" id="pagehead"><section class="section-header">
<h1 class="section-title" id="section-title">For You</h1>
<p class="section-subtitle" id="section-subtitle">
          Smart suggestions based on your favourite genres.
        </p>
</section><form autocomplete="off" class="search-form" id="search-form">
<div class="search-wrapper">
<span class="search-icon">üîç</span>
<input class="search-input" id="search-input" placeholder="Search within your recommendations‚Ä¶" type="search"/>
</div>
</form><div class="controls-bar" id="controls-bar">
<div class="controls-group">
<label class="controls-label">
<span>Sort by</span>
<select class="controls-select" id="sort-select">
<option value="default">Default</option>
<option value="title-asc">Title (A‚ÄìZ)</option>
<option value="year-desc">Year (newest)</option>
<option value="rating-desc">Rating (highest)</option>
<option value="popularity-desc">Popularity</option>
<option value="priority">Priority (watchlist)</option>
</select>
</label>
<label class="controls-label">
<span>Min rating</span>
<select class="controls-select" id="rating-filter-select">
<option value="0">Any</option>
<option value="5">5.0+</option>
<option value="7">7.0+</option>
<option value="8">8.0+</option>
</select>
</label>
<label class="controls-label">
<span>Mood</span>
<select class="controls-select" id="mood-select">
<option value="any">Any</option>
<option value="cosy">Cosy</option>
<option value="gory">Gory</option>
<option value="mindbendy">Mind-bendy</option>
<option value="feelgood">Feel-good</option>
<option value="darkhumour">Dark humour</option>
</select>
</label>
<label class="controls-label">
<span>Streaming</span>
<select class="controls-select" id="streaming-select">
<option value="any">Any</option>
<option value="first">Streaming-first</option>
<option value="only">Streaming only</option>
</select>
</label>
</div>
<div class="list-actions" id="list-actions"></div>
</div><div class="message" id="message">
        Pick favourite genres in Settings for personalised recommendations ‚Äî otherwise we‚Äôll show popular films.
      </div></div>




<div class="settings-panel" id="settings-panel"></div>
<div class="settings-panel" id="lists-panel"></div>
<div class="settings-panel" id="account-panel"></div>
<input accept="application/json" class="file-input-hidden" id="import-input" type="file"/>
<div class="grid" id="card-grid"></div>
<div class="debug" id="debug"></div>
</main>
</div>
<!-- Detail overlay -->
<div aria-hidden="true" class="detail-overlay hidden" id="detail-overlay">
<div aria-modal="true" class="detail-panel" role="dialog">
<div class="detail-header">
<div class="detail-title-block">
<div class="detail-title" id="detail-title"></div>
<div class="detail-meta" id="detail-meta"></div>
</div>
<button aria-label="Close" class="detail-close" id="detail-close" type="button">
          √ó
        </button>
</div>
<div class="detail-body">
<div class="detail-poster" id="detail-poster"></div>
<div class="detail-main">
<div class="detail-overview" id="detail-overview"></div>
<div class="detail-chips" id="detail-chips"></div>
<div class="detail-actions" id="detail-actions"></div>
<div id="detail-links"></div>
</div>
</div>
</div>
</div>
<!-- Burger menu overlay (mobile) -->
<div aria-hidden="true" class="menu-overlay hidden" id="menu-overlay">
<div aria-label="Navigation menu" aria-modal="true" class="menu-panel" role="dialog">
<div class="menu-header">
<div class="menu-title">Menu</div>
<button aria-label="Close menu" class="detail-close" id="menu-close" type="button">√ó</button>
</div>
<div class="menu-items">
<button class="menu-item" data-tab="for-you" type="button">For You</button>
<button class="menu-item" data-tab="discover" type="button">Discover</button>
<button class="menu-item" data-tab="watchlist" type="button">Watchlist</button>
<button class="menu-item" data-tab="watched" type="button">Watched</button>
<button class="menu-item" data-tab="lists" type="button">Lists</button>
<button class="menu-item" data-tab="account" type="button">Account</button>
<button class="menu-item" data-tab="settings" type="button">Settings</button>
</div>
<div class="menu-section" id="menu-pinned-section" style="display:none">
  <div class="menu-subtitle">Pinned lists</div>
  <div class="menu-pinned-items" id="menu-pinned-items"></div>
</div>
</div>
</div>
<script>
(function () {
      const TMDB_API_KEY = "b24323f85318cb1b12fd1ea0a94420de";

      const GENRES = [
        { id: 28, name: "Action" },
        { id: 12, name: "Adventure" },
        { id: 16, name: "Animation" },
        { id: 35, name: "Comedy" },
        { id: 80, name: "Crime" },
        { id: 99, name: "Documentary" },
        { id: 18, name: "Drama" },
        { id: 10751, name: "Family" },
        { id: 14, name: "Fantasy" },
        { id: 36, name: "History" },
        { id: 27, name: "Horror" },
        { id: 10402, name: "Music" },
        { id: 9648, name: "Mystery" },
        { id: 10749, name: "Romance" },
        { id: 878, name: "Science Fiction" },
        { id: 53, name: "Thriller" },
        { id: 37, name: "Western" }
      ];

// Smarter watchlist status (helps reflect reality)
const WATCH_PROGRESS_STATUS_LABELS = {
  planned: "Planned",
  started: "Started",
  paused: "Paused",
  abandoned: "Abandoned"
};
const WATCH_PROGRESS_STATUS_KEYS = ["planned","started","paused","abandoned"];

function normaliseWatchStatus(v) {
  const s = String(v || "").trim().toLowerCase();
  return WATCH_PROGRESS_STATUS_LABELS[s] ? s : "planned";
}



// TV genre mapping (TMDB uses different IDs for TV vs films)
const TV_GENRE_IDS_BY_NAME = {
  "Action": 10759, // Action & Adventure
  "Adventure": 10759,
  "Animation": 16,
  "Comedy": 35,
  "Crime": 80,
  "Documentary": 99,
  "Drama": 18,
  "Family": 10751,
  "Fantasy": 10765, // Sci-Fi & Fantasy (closest to Fantasy)
  "History": 10768, // War & Politics (closest)
  "Horror": 9648, // closest: Mystery/Thriller genres on TV are different; best-effort
  "Music": 10767, // Talk
  "Mystery": 9648,
  "Romance": 10749,
  "Science Fiction": 10765,
  "Thriller": 9648,
  "War": 10768,
  "Western": 37
};

function normaliseMediaType(mt) {
  return mt === "tv" ? "tv" : "movie";
}

// Infer media type when TMDB objects don't include `media_type` (common on /discover/movie or /discover/tv)
function inferMediaTypeFromTmdb(obj, fallback) {
  if (obj && typeof obj.media_type === "string" && obj.media_type.length) {
    return normaliseMediaType(obj.media_type);
  }
  // Heuristic: TV results usually have `name` and/or `first_air_date`
  const hasFirstAir = !!(obj && obj.first_air_date);
  const hasRelease = !!(obj && obj.release_date);
  const hasName = !!(obj && obj.name);
  const hasTitle = !!(obj && obj.title);
  if (hasFirstAir || (hasName && !hasTitle && !hasRelease)) return "tv";
  return normaliseMediaType(fallback);
}


function entryKey(mediaType, tmdbId) {
  const mt = normaliseMediaType(mediaType);
  return (mt === "tv" ? "t" : "m") + String(tmdbId);
}

function parseEntryKey(key) {
  if (typeof key === "number") return { mediaType: "movie", tmdbId: key };
  if (typeof key !== "string" || !key.length) return { mediaType: "movie", tmdbId: null };
  const first = key.charAt(0);
  const rest = key.slice(1);
  const id = parseInt(rest, 10);
  if (first === "t") return { mediaType: "tv", tmdbId: Number.isFinite(id) ? id : null };
  if (first === "m") return { mediaType: "movie", tmdbId: Number.isFinite(id) ? id : null };
  const id2 = parseInt(key, 10);
  return { mediaType: "movie", tmdbId: Number.isFinite(id2) ? id2 : null };
}



function toTmdbId(v) {
  if (typeof v === "number" && Number.isFinite(v)) return v;
  if (typeof v === "string") {
    const s = v.trim();
    if (/^[0-9]+$/.test(s)) {
      const n = parseInt(s, 10);
      return Number.isFinite(n) ? n : null;
    }
  }
  return null;
}
function titleFromTmdb(obj) {
  return (obj && (obj.title || obj.name)) ? (obj.title || obj.name) : "Untitled";
}

function yearFromTmdb(obj) {
  const d = obj ? (obj.release_date || obj.first_air_date || "") : "";
  return d ? String(d).slice(0, 4) : "";
}


const MOODS = {
  any: { label: "Any" },

  cosy: {
    label: "Cosy",
    movie: { include: [10751, 35, 16, 10749], exclude: [27, 53, 80], keywords: ["christmas", "holiday", "small town", "friendship"] },
    tv:    { include: [10751, 35, 16],        exclude: [80],        keywords: ["christmas", "holiday", "friendship"] }
  },

  gory: {
    label: "Gory",
    movie: { include: [27, 53], exclude: [10751, 10402], keywords: ["slasher", "splatter", "gore", "body horror", "zombie"] },
    tv:    { include: [80, 9648], exclude: [10751], keywords: ["slasher", "gore", "zombie"] }
  },

  mindbendy: {
    label: "Mind-bendy",
    movie: { include: [878, 9648, 53], exclude: [10751], keywords: ["time travel", "parallel universe", "twist ending", "psychological thriller"] },
    tv:    { include: [10765, 9648, 18], exclude: [10751], keywords: ["time travel", "parallel universe", "mystery"] }
  },

  feelgood: {
    label: "Feel-good",
    movie: { include: [35, 10751, 10749, 10402], exclude: [27], keywords: ["inspirational", "heartwarming", "friendship"] },
    tv:    { include: [35, 10751, 18], exclude: [80], keywords: ["heartwarming", "friendship"] }
  },

  darkhumour: {
    label: "Dark humour",
    movie: { include: [35, 80], exclude: [10751], keywords: ["dark comedy", "black comedy", "satire"] },
    tv:    { include: [35, 80], exclude: [10751], keywords: ["dark comedy", "satire"] }
  }
};

const keywordIdCache = {};

function migrateWatchProgressStatuses() {
  try {
    if (!state || !Array.isArray(state.items)) return;
    let changed = false;
    for (let i = 0; i < state.items.length; i++) {
      const it = state.items[i];
      if (!it) continue;

      // Back-compat: some builds used progressStatus
      if (typeof it.status === "undefined" && typeof it.progressStatus !== "undefined") {
        it.status = it.progressStatus;
        delete it.progressStatus;
        changed = true;
      }

      const inWl = !!it.inWatchlist;
      const watched = !!it.watched;

      if (inWl && !watched) {
        const norm = normaliseWatchStatus(it.status);
        if (it.status !== norm) { it.status = norm; changed = true; }
      } else {
        if (it.status != null) { it.status = null; changed = true; }
      }
    }
    if (changed) saveState();
  } catch (e) {
    console.error(e);
  }
}


function migrateWatchlistWatchedInvariant() {
  // Keep lists consistent: if something is marked watched, it should not remain in Watchlist,
  // and any in-progress status should be cleared.
  try {
    if (!state || !Array.isArray(state.items)) return;
    let changed = false;
    for (let i = 0; i < state.items.length; i++) {
      const it = state.items[i];
      if (!it) continue;

      if (it.watched) {
        if (it.inWatchlist) { it.inWatchlist = false; changed = true; }
        if (it.status != null) { it.status = null; changed = true; }
      } else {
        if (it.inWatchlist) {
          const norm = normaliseWatchStatus(it.status);
          if (it.status !== norm) { it.status = norm; changed = true; }
        }
      }

      // Rewatch implies watched
      if (it.rewatch && !it.watched) {
        it.watched = true;
        it.watchedAt = it.watchedAt || Date.now();
        it.inWatchlist = false;
        it.status = null;
        changed = true;
      }
    }
    if (changed) saveState();
  } catch (e) {
    console.error(e);
  }
}


// --- Streaming availability cache (subscription streaming / flatrate) ---
const streamingInfoCache = {};   // in-memory: key -> { f: boolean, ts: number }
const streamingPending = {};     // key -> Promise
let streamingInFlight = 0;

function streamingCacheKey(mediaType, tmdbId, country) {
  const mt = normaliseMediaType(mediaType);
  const id = toTmdbId(tmdbId);
  const cc = (country || "GB").toUpperCase();
  return mt + ":" + String(id) + ":" + cc;
}

function getStreamingInfo(mediaType, tmdbId) {
  const id = toTmdbId(tmdbId);
  if (id === null) return null;
  const mt = normaliseMediaType(mediaType);
  const cc = (state.country || "GB").toUpperCase();
  const key = streamingCacheKey(mt, id, cc);

  if (streamingInfoCache[key]) return streamingInfoCache[key];

  const cached = cacheGet("rq_stream_" + key, 1000 * 60 * 60 * 24 * 7); // 7 days
  if (cached && typeof cached.f === "boolean") {
    streamingInfoCache[key] = cached;
    return cached;
  }
  return null;
}

async function fetchStreamingInfo(mediaType, tmdbId) {
  const id = toTmdbId(tmdbId);
  if (id === null) return null;

  const mt = normaliseMediaType(mediaType);
  const cc = (state.country || "GB").toUpperCase();
  const key = streamingCacheKey(mt, id, cc);

  if (streamingPending[key]) return streamingPending[key];

  const task = (async () => {
    const path = (mt === "tv" ? "tv" : "movie");
    const url = new URL("https://api.themoviedb.org/3/" + path + "/" + id + "/watch/providers");
    url.searchParams.set("api_key", TMDB_API_KEY);
    try {
      const data = await tmdbFetch(url);
      const results = data && data.results ? data.results : {};
      const entry = results && results[cc] ? results[cc] : null;
      const hasFlat = !!(entry && Array.isArray(entry.flatrate) && entry.flatrate.length);
      const out = { f: hasFlat, ts: Date.now() };
      streamingInfoCache[key] = out;
      cacheSet("rq_stream_" + key, out);
      return out;
    } catch (e) {
      return null;
    }
  })();

  streamingPending[key] = task.finally(() => { try { delete streamingPending[key]; } catch (e) {} });
  return streamingPending[key];
}

function streamingFlagForView(view) {
  if (!view) return null;
  if (view.tmdbMovie) {
    const mt = normaliseMediaType(view.tmdbMovie.media_type || view.mediaType || "movie");
    const info = getStreamingInfo(mt, view.tmdbMovie.id);
    return info ? info.f : null;
  }
  if (view.item) {
    const mt = normaliseMediaType(view.item.mediaType || view.mediaType || "movie");
    const info = getStreamingInfo(mt, view.item.tmdbId);
    return info ? info.f : null;
  }
  return null;
}

function streamingPref() {
  const v = state.streamingMode || "any";
  return (v === "first" || v === "only") ? v : "any";
}

function ensureStreamingInfoForVisible(views) {
  const pref = streamingPref();
  if (pref === "any") {
    state.streamingLoading = false;
    return;
  }
  if (!Array.isArray(views) || !views.length) {
    state.streamingLoading = false;
    return;
  }

  const missing = [];
  for (let i = 0; i < views.length; i++) {
    const v = views[i];
    let mt = null;
    let id = null;

    if (v && v.tmdbMovie) {
      mt = normaliseMediaType(v.tmdbMovie.media_type || v.mediaType || "movie");
      id = toTmdbId(v.tmdbMovie.id);
    } else if (v && v.item) {
      mt = normaliseMediaType(v.item.mediaType || v.mediaType || "movie");
      id = toTmdbId(v.item.tmdbId);
    }

    if (id === null) continue;
    if (getStreamingInfo(mt, id) === null) missing.push({ mt: mt, id: id });
  }

  if (!missing.length) {
    state.streamingLoading = false;
    return;
  }

  const batch = missing.slice(0, 20);
  state.streamingLoading = true;
  streamingInFlight += batch.length;

  Promise.allSettled(batch.map((x) => fetchStreamingInfo(x.mt, x.id)))
    .then(() => {
      streamingInFlight -= batch.length;
      if (streamingInFlight <= 0) {
        streamingInFlight = 0;
        state.streamingLoading = false;
      }
      setTimeout(() => { try { render(); } catch (e) {} }, 0);
    });
}


async function resolveKeywordId(query) {
  const q = String(query || "").trim().toLowerCase();
  if (!q) return null;
  if (keywordIdCache[q] !== undefined) return keywordIdCache[q];

  const url = new URL("https://api.themoviedb.org/3/search/keyword");
  url.searchParams.set("api_key", TMDB_API_KEY);
  url.searchParams.set("query", q);

  try {
    const data = await tmdbFetch(url);
    const results = data && Array.isArray(data.results) ? data.results : [];
    if (results.length && typeof results[0].id === "number") {
      keywordIdCache[q] = results[0].id;
      return keywordIdCache[q];
    }
  } catch (e) {}

  keywordIdCache[q] = null;
  return null;
}

function getMoodKey() {
  return state.mood && MOODS[state.mood] ? state.mood : "any";
}

function getMoodConfig(mediaType) {
  const key = getMoodKey();
  if (key === "any") return null;
  const mt = normaliseMediaType(mediaType);
  return mt === "tv" ? MOODS[key].tv : MOODS[key].movie;
}

function genreIdsFromTmdb(tmdbObj) {
  if (!tmdbObj) return [];
  if (Array.isArray(tmdbObj.genre_ids)) {
    const out = [];
    for (let i = 0; i < tmdbObj.genre_ids.length; i++) {
      const v = tmdbObj.genre_ids[i];
      if (typeof v === "number") out.push(v);
    }
    return out;
  }
  if (Array.isArray(tmdbObj.genres)) {
    const out = [];
    for (let i = 0; i < tmdbObj.genres.length; i++) {
      const g = tmdbObj.genres[i];
      if (g && typeof g.id === "number") out.push(g.id);
    }
    return out;
  }
  return [];
}

function moodMatchesTmdb(tmdbObj) {
  const key = getMoodKey();
  if (key === "any") return true;
  if (!tmdbObj) return true;

  const ids = genreIdsFromTmdb(tmdbObj);
  const cfg = getMoodConfig(normaliseMediaType(tmdbObj.media_type || "movie"));
  if (!cfg) return true;

  if (Array.isArray(cfg.include) && cfg.include.length) {
    let ok = false;
    for (let i = 0; i < cfg.include.length; i++) {
      if (ids.indexOf(cfg.include[i]) !== -1) { ok = true; break; }
    }
    if (!ok) return false;
  }

  if (Array.isArray(cfg.exclude) && cfg.exclude.length) {
    for (let i = 0; i < cfg.exclude.length; i++) {
      if (ids.indexOf(cfg.exclude[i]) !== -1) return false;
    }
  }

  return true;
}

      const STORAGE_KEY = "reelquest-state-v7";

      let els = {};

      const state = {
        activeTab: "for-you",
        searchTerm: "",
        discoverResults: [],
        forYouResults: [],
        forYouLoading: false,
        forYouLoaded: false,
        radarResults: [],
        discoverMode: "default",
        discoverSeedTitle: "",
        filters: { minYear: 0, hideWatched: false, hideWatchlist: false, excludedGenres: [] },
        country: "GB",
        includeTv: true,
        mood: "any",
        localMoodLoading: false,
        streamingMode: "any",
        streamingLoading: false,
        items: [],
        lists: [],
        listsUi: { mode: "index", activeListId: null, reorderMode: false },
        favouriteGenres: [],
        sortBy: "default",
        minRating: 0,
        theme: "dark",
        detailsCache: {},
        ui: { selectionMode: false, selectedKeys: [] },
        lastTmdbStatus: ""
      };

      function updateDebug(msg) {
        state.lastTmdbStatus = msg;
        if (els.debug) {
          els.debug.textContent = msg;
        }
      }

      function safeId() {
        if (window.crypto && crypto.randomUUID) return crypto.randomUUID();
        return (
          "m_" +
          Date.now().toString(36) +
          "_" +
          Math.random().toString(16).slice(2)
        );
      }


function formatDateUK(ts) {
  try {
    return new Intl.DateTimeFormat("en-GB", {
      day: "2-digit",
      month: "short",
      year: "numeric"
    }).format(new Date(ts));
  } catch (e) {
    const d = new Date(ts);
    return d.toISOString().slice(0, 10);
  }
}

      function loadState() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return;
          const parsed = JSON.parse(raw);
          if (Array.isArray(parsed.items)) {
            state.items = parsed.items;
          }
          if (Array.isArray(parsed.favouriteGenres)) {
            state.favouriteGenres = parsed.favouriteGenres;
          }
          if (parsed.sortBy) {
            state.sortBy = parsed.sortBy;
          }
          if (typeof parsed.minRating === "number") {
            state.minRating = parsed.minRating;
          }
          if (Array.isArray(parsed.lists)) {
            state.lists = parsed.lists;
          }
          if (parsed.listsUi && typeof parsed.listsUi === "object") {
            state.listsUi = {
              mode: parsed.listsUi.mode === "detail" ? "detail" : "index",
              activeListId: parsed.listsUi.activeListId || null
            };
          }
          if (typeof parsed.country === "string" && parsed.country.length === 2) {
            state.country = parsed.country.toUpperCase();
          }

          if (typeof parsed.includeTv === "boolean") {
            state.includeTv = parsed.includeTv;
          }
          if (typeof parsed.mood === "string" && MOODS[parsed.mood]) {
            state.mood = parsed.mood;
          }

          if (typeof parsed.streamingMode === "string") {
            const sm = parsed.streamingMode;
            state.streamingMode = (sm === "first" || sm === "only") ? sm : "any";
          }

if (parsed.ui && typeof parsed.ui === "object") {
  state.ui = {
    selectionMode: !!parsed.ui.selectionMode,
    selectedKeys: Array.isArray(parsed.ui.selectedKeys)
      ? parsed.ui.selectedKeys.filter(function (n) { return typeof n === "string" && n.length; })
      : []
  };
}

          if (parsed.theme === "light" || parsed.theme === "dark") {
            state.theme = parsed.theme;
          }
        } catch (e) {
          console.warn("Failed to load ReelQuest state", e);
        }
      }

function migrateItemsMediaType() {
  // Backwards compatibility: older saves had films only and no mediaType.
  for (let i = 0; i < state.items.length; i++) {
    if (!state.items[i].mediaType) state.items[i].mediaType = "movie";
  }
  for (let i = 0; i < state.lists.length; i++) {
    const l = state.lists[i];
    if (!l || !Array.isArray(l.entries)) continue;
    for (let j = 0; j < l.entries.length; j++) {
      if (!l.entries[j].mediaType) l.entries[j].mediaType = "movie";
    }
  }
}

function migrateTmdbIdsToNumbers() {
  let changed = false;

  for (let i = 0; i < state.items.length; i++) {
    const it = state.items[i];
    if (!it) continue;
    const n = toTmdbId(it.tmdbId);
    if (n !== null && it.tmdbId !== n) {
      it.tmdbId = n;
      changed = true;
    }
  }

  for (let i = 0; i < state.lists.length; i++) {
    const l = state.lists[i];
    if (!l || !Array.isArray(l.entries)) continue;
    for (let j = 0; j < l.entries.length; j++) {
      const e = l.entries[j];
      if (!e) continue;
      const n = toTmdbId(e.tmdbId);
      if (n !== null && e.tmdbId !== n) {
        e.tmdbId = n;
        changed = true;
      }
    }
    if (l && Array.isArray(l.customOrder)) {
      for (let j = 0; j < l.customOrder.length; j++) {
        const n = toTmdbId(l.customOrder[j]);
        if (n !== null && l.customOrder[j] !== n) {
          l.customOrder[j] = n;
          changed = true;
        }
      }
    }
  }

  if (changed) saveState();
}



function toast(message, options) {
  const host = document.getElementById("toast-host");
  if (!host) {
    alertNice(message);
    return;
  }

  const opts = options && typeof options === "object" ? options : {};
  const duration = typeof opts.duration === "number" ? opts.duration : 2400;
  const actionText = typeof opts.actionText === "string" ? opts.actionText : null;
  const onAction = typeof opts.onAction === "function" ? opts.onAction : null;

  const el = document.createElement("div");
  el.className = "toast" + (document.body.classList.contains("light") ? " toast-light" : "");
  const msg = document.createElement("div");
  msg.className = "toast-msg";
  msg.textContent = message;

  const actions = document.createElement("div");
  actions.className = "toast-actions";

  if (actionText && onAction) {
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "toast-btn";
    btn.textContent = actionText;
    btn.addEventListener("click", function () {
      try { onAction(); } catch (e) { console.error(e); }
      dismiss();
    });
    actions.appendChild(btn);
  }

  const closeBtn = document.createElement("button");
  closeBtn.type = "button";
  closeBtn.className = "toast-btn";
  closeBtn.textContent = "Dismiss";
  closeBtn.addEventListener("click", function () { dismiss(); });
  actions.appendChild(closeBtn);

  el.appendChild(msg);
  el.appendChild(actions);
  host.appendChild(el);

  let gone = false;
  const timer = window.setTimeout(function () { dismiss(); }, duration);

  function dismiss() {
    if (gone) return;
    gone = true;
    window.clearTimeout(timer);
    el.style.animation = "toastOut 140ms ease-in forwards";
    window.setTimeout(function () {
      try { el.remove(); } catch (e) {}
    }, 160);
  }
}

function alertNice(message) {
  toast(message);
}

      function saveState() {
        try {
          localStorage.setItem(
            STORAGE_KEY,
            JSON.stringify({
              items: state.items,
              lists: state.lists,
              listsUi: state.listsUi,
              filters: state.filters,
              favouriteGenres: state.favouriteGenres,
              sortBy: state.sortBy,
              minRating: state.minRating,
              country: state.country,
              includeTv: state.includeTv,
              mood: state.mood,
              streamingMode: state.streamingMode,
              ui: state.ui,
              theme: state.theme
            })
          );
        } catch (e) {
          console.warn("Failed to save ReelQuest state", e);
        }
      }


function cacheSet(key, value) {
  try {
    const payload = { ts: Date.now(), value: value };
    localStorage.setItem(key, JSON.stringify(payload));
  } catch (e) {}
}

function cacheGet(key, maxAgeMs) {
  try {
    const raw = localStorage.getItem(key);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== "object") return null;
    if (typeof parsed.ts !== "number") return null;
    if (typeof maxAgeMs === "number" && maxAgeMs > 0) {
      if (Date.now() - parsed.ts > maxAgeMs) return null;
    }
    return parsed.value;
  } catch (e) { return null; }
}

function isOffline() { return typeof navigator !== "undefined" && navigator.onLine === false; }

function isBulkSelectableTab() {
  return state.activeTab === "watchlist" || state.activeTab === "watched" || state.activeTab === "rewatch" ||
    (state.activeTab === "lists" && state.listsUi && state.listsUi.mode === "detail");
}

function clearSelection() {
  state.ui.selectionMode = false;
  state.ui.selectedKeys = [];
  saveState();
  render();
}

function getKeyFromView(view) {
  if (!view) return null;
  if (view.mode === "local" && view.item) {
    const id = toTmdbId(view.item.tmdbId);
    if (id !== null) return entryKey(view.item.mediaType || "movie", id);
  }
  if (view.mode === "remote" && view.tmdbMovie) {
    const id = toTmdbId(view.tmdbMovie.id);
    if (id !== null) return entryKey(view.mediaType || view.tmdbMovie.media_type || "movie", id);
  }
  return null;
}

function isSelectedKey(id) {
  if (typeof id !== "number") return false;
  for (let i = 0; i < state.ui.selectedKeys.length; i++) {
    if (state.ui.selectedKeys[i] === id) return true;
  }
  return false;
}

function toggleSelectedKey(id) {
  if (typeof id !== "number") return;
  const next = [];
  let found = false;
  for (let i = 0; i < state.ui.selectedKeys.length; i++) {
    const v = state.ui.selectedKeys[i];
    if (v === id) { found = true; continue; }
    next.push(v);
  }
  if (!found) next.push(id);
  state.ui.selectedKeys = next;
  saveState();
  render();
}

function openModalSheet(opts) {
  const options = opts && typeof opts === "object" ? opts : {};
  const overlay = document.createElement("div");
  overlay.className = "modal-overlay";
  overlay.addEventListener("click", function (e) {
    if (e.target === overlay) close();
  });

  const sheet = document.createElement("div");
  sheet.className = "modal-sheet";
  overlay.appendChild(sheet);

  const header = document.createElement("div");
  header.className = "modal-header";

  const title = document.createElement("div");
  title.className = "modal-title";
  title.textContent = typeof options.title === "string" ? options.title : "Choose";
  header.appendChild(title);

  const closeBtn = document.createElement("button");
  closeBtn.type = "button";
  closeBtn.className = "pill-btn";
  closeBtn.textContent = "Close";
  closeBtn.addEventListener("click", close);
  header.appendChild(closeBtn);

  sheet.appendChild(header);

  const body = document.createElement("div");
  body.className = "modal-body";
  sheet.appendChild(body);

  if (typeof options.render === "function") {
    options.render(body, close);
  }

  document.body.appendChild(overlay);

  function close() {
    try { overlay.remove(); } catch (e) {}
  }

  return { close: close, body: body };
}

function getSelectedViewsForCurrentTab() {
  const views = getViewItemsForCurrentTab();
        ensureStreamingInfoForVisible(views);
  const picked = [];
  for (let i = 0; i < views.length; i++) {
    const id = getKeyFromView(views[i]);
    if (id && isSelectedKey(id)) picked.push(views[i]);
  }
  return picked;
}

function bulkMoveSelectedToWatched(views) {
  let changed = 0;
  for (let i = 0; i < views.length; i++) {
    const v = views[i];
    let item = null;
    if (v.mode === "local" && v.item) item = v.item;
    if (v.mode === "remote" && v.tmdbMovie) item = ensureItemFromTmdb(v.tmdbMovie, v.mediaType || (v.tmdbMovie && v.tmdbMovie.media_type));
    if (!item) continue;

    if (!item.watched) {
      item.watched = true;
      item.inWatchlist = false;
      item.status = null;
      if (!item.watchedAt) item.watchedAt = Date.now();
      changed++;
    } else if (item.inWatchlist) {
      item.inWatchlist = false;
      changed++;
    }
  }
  if (changed) {
    saveState();
    render();
    toast("Moved " + changed + " film" + (changed === 1 ? "" : "s") + " to watched.");
  } else {
    toast("Nothing to move.");
  }
}

function bulkRemoveSelectedFromContext(views) {
  let changed = 0;

  // Lists detail removal
  if (state.activeTab === "lists" && state.listsUi && state.listsUi.mode === "detail") {
    const list = getListById(state.listsUi.activeListId);
    if (!list || list.type !== "manual") { toast("Nothing to remove."); return; }

    const ids = [];
    for (let i = 0; i < views.length; i++) {
      const id = getKeyFromView(views[i]);
      if (id) ids.push(id);
    }

    const next = [];
    for (let i = 0; i < list.entries.length; i++) {
      const e = list.entries[i];
      if (e && ids.indexOf(e.tmdbId) !== -1) { changed++; continue; }
      next.push(e);
    }
    list.entries = next;

    ensureCustomOrder(list);
    const nextOrder = [];
    for (let i = 0; i < list.customOrder.length; i++) {
      if (ids.indexOf(list.customOrder[i]) === -1) nextOrder.push(list.customOrder[i]);
    }
    list.customOrder = nextOrder;

    saveState();
    render();

    if (changed) toast("Removed " + changed + " film" + (changed === 1 ? "" : "s") + " from the list.");
    else toast("Nothing to remove.");
    return;
  }

  for (let i = 0; i < views.length; i++) {
    const v = views[i];
    let item = null;
    if (v.mode === "local" && v.item) item = v.item;
    if (v.mode === "remote" && v.tmdbMovie) item = ensureItemFromTmdb(v.tmdbMovie, v.mediaType || (v.tmdbMovie && v.tmdbMovie.media_type));
    if (!item) continue;

    if (state.activeTab === "watchlist") {
      if (item.inWatchlist) { item.inWatchlist = false; changed++; }
    } else if (state.activeTab === "watched") {
      if (item.watched) { item.watched = false; item.rewatch = false; changed++; }
    } else if (state.activeTab === "rewatch") {
      if (item.rewatch) { item.rewatch = false; changed++; }
    }
  }

  if (changed) {
    saveState();
    render();
    toast("Removed " + changed + " film" + (changed === 1 ? "" : "s") + ".");
  } else {
    toast("Nothing to remove.");
  }
}

function bulkAddSelectedViewsToList(views, listId) {
  const list = getListById(listId);
  if (!list || list.type !== "manual") return;

  let added = 0;
  const exists = {};
  for (let i = 0; i < list.entries.length; i++) {
    const e = list.entries[i];
    if (e && typeof e.tmdbId === "number") exists[e.tmdbId] = true;
  }

  for (let i = 0; i < views.length; i++) {
    const v = views[i];
    const tmdbId = getKeyFromView(v);
    if (!tmdbId || exists[tmdbId]) continue;

    let title = "Untitled";
    let year = "";
    let posterPath = null;
    let rating = null;

    if (v.mode === "remote" && v.tmdbMovie) {
      title = v.tmdbMovie.title || v.tmdbMovie.name || "Untitled";
      year = v.tmdbMovie.release_date ? v.tmdbMovie.release_date.slice(0, 4) : "";
      posterPath = v.tmdbMovie.poster_path || null;
      rating = typeof v.tmdbMovie.vote_average === "number" ? v.tmdbMovie.vote_average : null;
      ensureItemFromTmdb(v.tmdbMovie, v.mediaType || (v.tmdbMovie && v.tmdbMovie.media_type));
    } else if (v.mode === "local" && v.item) {
      title = v.item.title || "Untitled";
      year = v.item.year || "";
      posterPath = v.item.posterPath || null;
      rating = typeof v.item.rating === "number" ? v.item.rating : null;
    }

    list.entries.push({ tmdbId: tmdbId, title: title, year: year, posterPath: posterPath, rating: rating, addedAt: Date.now() });
    ensureCustomOrder(list);
    if (list.customOrder.indexOf(tmdbId) === -1) list.customOrder.push(tmdbId);

    exists[tmdbId] = true;
    added++;
  }

  if (added) {
    saveState();
    render();
    toast("Added " + added + " film" + (added === 1 ? "" : "s") + " to the list.");
  } else {
    toast("Nothing new to add.");
  }
}

function openBulkAddToListPicker(selectedViews) {
  const manualLists = [];
  for (let i = 0; i < state.lists.length; i++) {
    const l = state.lists[i];
    if (l && l.type === "manual") manualLists.push(l);
  }

  openModalSheet({
    title: "Add to a list",
    render: function (body, close) {
      const copy = document.createElement("p");
      copy.className = "settings-copy";
      copy.style.margin = "0";
      copy.textContent = "Choose a list to add the selected films to.";
      body.appendChild(copy);

      const listWrap = document.createElement("div");
      listWrap.className = "modal-list";
      body.appendChild(listWrap);

      if (!manualLists.length) {
        const empty = document.createElement("div");
        empty.className = "settings-copy";
        empty.style.margin = "0";
        empty.textContent = "You don‚Äôt have any lists yet. Create one first.";
        listWrap.appendChild(empty);
      } else {
        for (let i = 0; i < manualLists.length; i++) {
          const l = manualLists[i];
          const row = document.createElement("div");
          row.className = "modal-row";

          const left = document.createElement("div");
          const name = document.createElement("strong");
          name.textContent = l.name || "Untitled list";
          const meta = document.createElement("small");
          meta.textContent = (l.entries ? l.entries.length : 0) + " films";
          left.appendChild(name);
          left.appendChild(document.createElement("br"));
          left.appendChild(meta);

          const addBtn = document.createElement("button");
          addBtn.type = "button";
          addBtn.className = "pill-btn";
          addBtn.textContent = "Add";
          addBtn.addEventListener("click", function () {
            bulkAddSelectedViewsToList(selectedViews, l.id);
            close();
            clearSelection();
          });

          row.appendChild(left);
          row.appendChild(addBtn);
          listWrap.appendChild(row);
        }
      }
    }
  });
}

      function applyTheme() {
        if (state.theme === "light") {
          document.body.classList.add("theme-light");
          if (els.themeToggle) els.themeToggle.textContent = "‚òÄÔ∏é";
        } else {
          document.body.classList.remove("theme-light");
          if (els.themeToggle) els.themeToggle.textContent = "‚òæ";
        }
      }

      function toggleTheme() {
        state.theme = state.theme === "dark" ? "light" : "dark";
        applyTheme();
        saveState();
      }

      async function tmdbFetch(url) {
        updateDebug("Calling TMDB: " + url.toString());
        const res = await fetch(url.toString(), {
          headers: {
            Accept: "application/json"
          }
        });
        updateDebug("TMDB status: " + res.status);
        if (!res.ok) {
          let text = "";
          try {
            text = await res.text();
          } catch (e) {}
          updateDebug("TMDB error " + res.status + ": " + text);
          throw new Error("TMDB request failed with " + res.status);
        }
        const data = await res.json();
        return data;
      }

      async function searchTmdb(query) {
  // Combined search (films + TV). TV can be hidden via Settings.
  const q = String(query || "").trim();
  if (!q) return [];

  const movieUrl = new URL("https://api.themoviedb.org/3/search/movie");
  movieUrl.searchParams.set("api_key", TMDB_API_KEY);
  movieUrl.searchParams.set("query", q);
  movieUrl.searchParams.set("include_adult", "false");
  movieUrl.searchParams.set("language", "en-GB");
  movieUrl.searchParams.set("page", "1");

  if (!state.includeTv) {
    const data = await tmdbFetch(movieUrl);
    const res = Array.isArray(data.results) ? data.results : [];
    for (let i = 0; i < res.length; i++) res[i].media_type = "movie";
    return res;
  }

  const tvUrl = new URL("https://api.themoviedb.org/3/search/tv");
  tvUrl.searchParams.set("api_key", TMDB_API_KEY);
  tvUrl.searchParams.set("query", q);
  tvUrl.searchParams.set("include_adult", "false");
  tvUrl.searchParams.set("language", "en-GB");
  tvUrl.searchParams.set("page", "1");

  const pair = await Promise.all([tmdbFetch(movieUrl), tmdbFetch(tvUrl)]);
  const movies = Array.isArray(pair[0].results) ? pair[0].results : [];
  const tv = Array.isArray(pair[1].results) ? pair[1].results : [];

  for (let i = 0; i < movies.length; i++) movies[i].media_type = "movie";
  for (let i = 0; i < tv.length; i++) tv[i].media_type = "tv";

  const merged = movies.concat(tv);
  merged.sort(function (a, b) { return (b.popularity || 0) - (a.popularity || 0); });
  return merged.slice(0, 40);
}

      function renderSkeletonGrid(count) {
  const n = typeof count === "number" ? count : 10;
  els.grid.innerHTML = "";
  for (let i = 0; i < n; i++) {
    const card = document.createElement("div");
    card.className = "skeleton-card shimmer";

    const thumb = document.createElement("div");
    thumb.className = "skeleton-thumb";
    card.appendChild(thumb);

    const lines = document.createElement("div");
    lines.className = "skeleton-lines";
    const l1 = document.createElement("div");
    l1.className = "skeleton-line";
    const l2 = document.createElement("div");
    l2.className = "skeleton-line short";
    const l3 = document.createElement("div");
    l3.className = "skeleton-line tiny";
    lines.appendChild(l1);
    lines.appendChild(l2);
    lines.appendChild(l3);

    card.appendChild(lines);
    els.grid.appendChild(card);
  }
}

async function loadBecauseYouLiked(tmdbId, seedTitle, mediaType) {
  const mt = normaliseMediaType(mediaType || "movie");
  state.activeTab = "discover";
  state.discoverMode = "because";
  state.discoverSeedTitle = seedTitle || "";
  state.searchTerm = "";
  if (els.searchInput) els.searchInput.value = "";
  els.message.style.display = "block";
  els.message.textContent = "Loading more like this‚Ä¶";
  renderSkeletonGrid(10);

  try {
    const base = "https://api.themoviedb.org/3/" + mt + "/" + tmdbId + "/";
    const recUrl = new URL(base + "recommendations");
    recUrl.searchParams.set("api_key", TMDB_API_KEY);
    recUrl.searchParams.set("language", "en-GB");
    recUrl.searchParams.set("page", "1");

    const simUrl = new URL(base + "similar");
    simUrl.searchParams.set("api_key", TMDB_API_KEY);
    simUrl.searchParams.set("language", "en-GB");
    simUrl.searchParams.set("page", "1");

    const [recData, simData] = await Promise.all([
      tmdbFetch(recUrl).catch(() => null),
      tmdbFetch(simUrl).catch(() => null)
    ]);

    const merged = [];
    const seen = new Set();

    function addResults(arr) {
      if (!Array.isArray(arr)) return;
      for (let i = 0; i < arr.length; i++) {
        const it = arr[i];
        if (!it || typeof it.id !== "number") continue;
        if (seen.has(it.id)) continue;
        seen.add(it.id);
        it.media_type = mt; // important for TV cards + detail
        merged.push(it);
      }
    }

    addResults(recData && recData.results);
    addResults(simData && simData.results);

    // Mood filter (if active)
    let out = merged;
    if (state.mood && state.mood !== "any") {
      const mf = [];
      for (let i = 0; i < out.length; i++) if (moodMatchesTmdb(out[i])) mf.push(out[i]);
      out = mf;
    }

    state.discoverResults = out.slice(0, 40);
    if (!state.discoverResults.length) {
      els.message.textContent = "No matches found ‚Äî try a different mood or broaden your filters.";
    } else {
      els.message.style.display = "none";
    }
  } catch (err) {
    console.error(err);
    state.discoverResults = [];
    els.message.textContent = "We couldn‚Äôt load similar titles. Please try again.";
  } finally {
    render();
  }
}

async function loadMoodForDiscover() {
  if (!els.message || !els.grid) return;

  const moodKey = getMoodKey();
  if (moodKey === "any") {
    await loadPopularForDiscover();
    return;
  }

  els.message.style.display = "block";
  els.message.textContent = "Loading " + MOODS[moodKey].label.toLowerCase() + " picks‚Ä¶";
  renderSkeletonGrid(12);

  try {
    const results = [];

    const movieCfg = getMoodConfig("movie");
    const movieUrl = new URL("https://api.themoviedb.org/3/discover/movie");
    movieUrl.searchParams.set("api_key", TMDB_API_KEY);
    movieUrl.searchParams.set("language", "en-GB");
    movieUrl.searchParams.set("include_adult", "false");
    movieUrl.searchParams.set("sort_by", "popularity.desc");
    movieUrl.searchParams.set("page", "1");
    if (movieCfg && movieCfg.include && movieCfg.include.length) movieUrl.searchParams.set("with_genres", movieCfg.include.join(","));
    if (movieCfg && movieCfg.exclude && movieCfg.exclude.length) movieUrl.searchParams.set("without_genres", movieCfg.exclude.join(","));
    if (movieCfg && movieCfg.keywords && movieCfg.keywords.length) {
      const ids = [];
      for (let i = 0; i < movieCfg.keywords.length; i++) {
        const id = await resolveKeywordId(movieCfg.keywords[i]);
        if (id) ids.push(id);
        if (ids.length >= 4) break;
      }
      if (ids.length) movieUrl.searchParams.set("with_keywords", ids.join("|"));
    }

    const movieData = await tmdbFetch(movieUrl);
    const movies = movieData && Array.isArray(movieData.results) ? movieData.results : [];
    for (let i = 0; i < movies.length; i++) {
      movies[i].media_type = "movie";
      results.push(movies[i]);
    }

    if (state.includeTv) {
      const tvCfg = getMoodConfig("tv");
      const tvUrl = new URL("https://api.themoviedb.org/3/discover/tv");
      tvUrl.searchParams.set("api_key", TMDB_API_KEY);
      tvUrl.searchParams.set("language", "en-GB");
      tvUrl.searchParams.set("sort_by", "popularity.desc");
      tvUrl.searchParams.set("page", "1");
      if (tvCfg && tvCfg.include && tvCfg.include.length) tvUrl.searchParams.set("with_genres", tvCfg.include.join(","));
      if (tvCfg && tvCfg.exclude && tvCfg.exclude.length) tvUrl.searchParams.set("without_genres", tvCfg.exclude.join(","));
      if (tvCfg && tvCfg.keywords && tvCfg.keywords.length) {
        const ids = [];
        for (let i = 0; i < tvCfg.keywords.length; i++) {
          const id = await resolveKeywordId(tvCfg.keywords[i]);
          if (id) ids.push(id);
          if (ids.length >= 4) break;
        }
        if (ids.length) tvUrl.searchParams.set("with_keywords", ids.join("|"));
      }

      let tvData = null;
      try {
        tvData = await tmdbFetch(tvUrl);
      } catch (e) {
        tvUrl.searchParams.delete("with_keywords");
        tvData = await tmdbFetch(tvUrl);
      }

      const tv = tvData && Array.isArray(tvData.results) ? tvData.results : [];
      for (let i = 0; i < tv.length; i++) {
        tv[i].media_type = "tv";
        results.push(tv[i]);
      }
    }

    results.sort(function (a, b) { return (b.popularity || 0) - (a.popularity || 0); });
    state.discoverResults = results.slice(0, 40);
    cacheSet("rq_cache_discover", { results: state.discoverResults, meta: { country: state.country, includeTv: state.includeTv, mood: state.mood } });
  } catch (err) {
    console.error(err);
    const cached = cacheGet("rq_cache_discover", 1000 * 60 * 60 * 24 * 21);
    if (cached && Array.isArray(cached.results) && cached.results.length) {
      state.discoverResults = cached.results;
      els.message.style.display = "block";
      els.message.textContent = "Offline ‚Äî showing the last saved Discover results.";
    } else {
      state.discoverResults = [];
      els.message.textContent = "We couldn‚Äôt load Discover picks. Please check your connection.";
    }
  } finally {
    render();
  }
}async function loadPopularForDiscover() {
  if (!els.message || !els.grid) return;
  els.message.style.display = "block";
  els.message.textContent = state.includeTv ? "Loading popular titles‚Ä¶" : "Loading popular films‚Ä¶";

        if (state.mood && state.mood !== "any") {
          await loadMoodForDiscover();
          return;
        }
  renderSkeletonGrid(12);

  try {
    const movieUrl = new URL("https://api.themoviedb.org/3/movie/popular");
    movieUrl.searchParams.set("api_key", TMDB_API_KEY);
    movieUrl.searchParams.set("language", "en-GB");
    movieUrl.searchParams.set("page", "1");

    if (!state.includeTv) {
      const data = await tmdbFetch(movieUrl);
      const res = Array.isArray(data.results) ? data.results : [];
      for (let i = 0; i < res.length; i++) res[i].media_type = "movie";
      state.discoverResults = res;
      cacheSet("rq_cache_discover", { results: state.discoverResults, meta: { country: state.country, includeTv: state.includeTv } });
      render();
      return;
    }

    const tvUrl = new URL("https://api.themoviedb.org/3/tv/popular");
    tvUrl.searchParams.set("api_key", TMDB_API_KEY);
    tvUrl.searchParams.set("language", "en-GB");
    tvUrl.searchParams.set("page", "1");

    const pair = await Promise.all([tmdbFetch(movieUrl), tmdbFetch(tvUrl)]);
    const movies = Array.isArray(pair[0].results) ? pair[0].results : [];
    const tv = Array.isArray(pair[1].results) ? pair[1].results : [];

    for (let i = 0; i < movies.length; i++) movies[i].media_type = "movie";
    for (let i = 0; i < tv.length; i++) tv[i].media_type = "tv";

    const merged = movies.concat(tv);
    merged.sort(function (a, b) { return (b.popularity || 0) - (a.popularity || 0); });

    state.discoverResults = merged.slice(0, 40);
    cacheSet("rq_cache_discover", { results: state.discoverResults, meta: { country: state.country, includeTv: state.includeTv } });
  } catch (err) {
    const cached = cacheGet("rq_cache_discover", 1000 * 60 * 60 * 24 * 21);
    if (cached && Array.isArray(cached.results) && cached.results.length) {
      state.discoverResults = cached.results;
      if (els && els.message) {
        els.message.style.display = "block";
        els.message.textContent = "Offline ‚Äî showing the last saved Discover results.";
      }
      render();
      return;
    }
    console.error(err);
    state.discoverResults = [];
    els.message.textContent = "We couldn‚Äôt load popular titles. Please check your connection.";
  } finally {
    render();
  }
}

      async function loadRadarUpcoming() {
  els.message.style.display = "block";
  els.message.textContent = state.includeTv ? "Loading upcoming and on-air titles‚Ä¶" : "Loading upcoming releases‚Ä¶";
  renderSkeletonGrid(12);

  try {
    const movieUrl = new URL("https://api.themoviedb.org/3/movie/upcoming");
    movieUrl.searchParams.set("api_key", TMDB_API_KEY);
    movieUrl.searchParams.set("language", "en-GB");
    movieUrl.searchParams.set("region", (state.country || "GB"));
    movieUrl.searchParams.set("page", "1");

    if (!state.includeTv) {
      const data = await tmdbFetch(movieUrl);
      const res = Array.isArray(data.results) ? data.results : [];
      for (let i = 0; i < res.length; i++) res[i].media_type = "movie";
      state.radarResults = res;
      cacheSet("rq_cache_radar", { results: state.radarResults, meta: { country: state.country, includeTv: state.includeTv } });
      render();
      return;
    }

    const tvUrl = new URL("https://api.themoviedb.org/3/tv/on_the_air");
    tvUrl.searchParams.set("api_key", TMDB_API_KEY);
    tvUrl.searchParams.set("language", "en-GB");
    tvUrl.searchParams.set("page", "1");

    const pair = await Promise.all([tmdbFetch(movieUrl), tmdbFetch(tvUrl)]);
    const movies = Array.isArray(pair[0].results) ? pair[0].results : [];
    const tv = Array.isArray(pair[1].results) ? pair[1].results : [];

    for (let i = 0; i < movies.length; i++) movies[i].media_type = "movie";
    for (let i = 0; i < tv.length; i++) tv[i].media_type = "tv";

    const merged = movies.concat(tv);
    merged.sort(function (a, b) {
      const da = Date.parse((a.release_date || a.first_air_date || "") + "T00:00:00Z");
      const db = Date.parse((b.release_date || b.first_air_date || "") + "T00:00:00Z");
      const na = Number.isFinite(da) ? da : 0;
      const nb = Number.isFinite(db) ? db : 0;
      if (na && nb) return na - nb;
      return (b.popularity || 0) - (a.popularity || 0);
    });

    state.radarResults = merged.slice(0, 40);
    cacheSet("rq_cache_radar", { results: state.radarResults, meta: { country: state.country, includeTv: state.includeTv } });
  } catch (err) {
    const cached = cacheGet("rq_cache_radar", 1000 * 60 * 60 * 24 * 21);
    if (cached && Array.isArray(cached.results) && cached.results.length) {
      state.radarResults = cached.results;
      if (els && els.message) {
        els.message.style.display = "block";
        els.message.textContent = "Offline ‚Äî showing the last saved Radar results.";
      }
      render();
      return;
    }
    console.error(err);
    state.radarResults = [];
    els.message.textContent = "We couldn‚Äôt load Radar titles. Please check your connection.";
  } finally {
    render();
  }
}

      function downloadIcsReminder(title, dateIso) {
        // dateIso expected yyyy-mm-dd
        if (!dateIso) {
          alertNice("No release date available for this film.");
          return;
        }
        const parts = dateIso.split("-");
        if (parts.length < 3) return;

        const y = parts[0], m = parts[1], d = parts[2];

        // All-day event: DTSTART;VALUE=DATE:YYYYMMDD (end date is next day)
        function pad2(n) { return String(n).padStart(2, "0"); }
        const ymd = String(y) + String(m) + String(d);

        // End date next day (simple, safe: create a Date)
        const dt = new Date(parseInt(y,10), parseInt(m,10)-1, parseInt(d,10));
        const dtEnd = new Date(dt.getTime() + 24*60*60*1000);
        const ymdEnd = String(dtEnd.getFullYear()) + pad2(dtEnd.getMonth()+1) + pad2(dtEnd.getDate());

        const uid = "reelquest-" + Date.now() + "@reelquest";
        const summary = (title || "Film release") + " (Release)";

        const ics =
          "BEGIN:VCALENDAR\r\n" +
          "VERSION:2.0\r\n" +
          "PRODID:-//ReelQuest//EN\r\n" +
          "CALSCALE:GREGORIAN\r\n" +
          "BEGIN:VEVENT\r\n" +
          "UID:" + uid + "\r\n" +
          "DTSTAMP:" + new Date().toISOString().replace(/[-:]/g, "").split(".")[0] + "Z\r\n" +
          "SUMMARY:" + summary.replace(/\n/g, " ") + "\r\n" +
          "DTSTART;VALUE=DATE:" + ymd + "\r\n" +
          "DTEND;VALUE=DATE:" + ymdEnd + "\r\n" +
          "BEGIN:VALARM\r\n" +
          "TRIGGER:-P1D\r\n" +
          "ACTION:DISPLAY\r\n" +
          "DESCRIPTION:ReelQuest reminder\r\n" +
          "END:VALARM\r\n" +
          "END:VEVENT\r\n" +
          "END:VCALENDAR\r\n";

        const blob = new Blob([ics], { type: "text/calendar" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "reelquest-reminder.ics";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        setTimeout(function(){ URL.revokeObjectURL(url); }, 1000);
      }

async function loadForYouFallbackPopular() {
  els.message.style.display = "block";
  els.message.textContent = state.includeTv ? "Loading popular titles‚Ä¶" : "Loading popular films‚Ä¶";
  renderSkeletonGrid(12);

  try {
    const movieUrl = new URL("https://api.themoviedb.org/3/movie/popular");
    movieUrl.searchParams.set("api_key", TMDB_API_KEY);
    movieUrl.searchParams.set("language", "en-GB");
    movieUrl.searchParams.set("page", "1");

    if (!state.includeTv) {
      const data = await tmdbFetch(movieUrl);
      const res = Array.isArray(data.results) ? data.results : [];
      for (let i = 0; i < res.length; i++) res[i].media_type = "movie";
      state.forYouResults = res;
      state.forYouLoaded = true;
      cacheSet("rq_cache_forYou", { results: state.forYouResults, meta: { country: state.country, favouriteGenres: state.favouriteGenres, includeTv: state.includeTv } });
      render();
      return;
    }

    const tvUrl = new URL("https://api.themoviedb.org/3/tv/popular");
    tvUrl.searchParams.set("api_key", TMDB_API_KEY);
    tvUrl.searchParams.set("language", "en-GB");
    tvUrl.searchParams.set("page", "1");

    const pair = await Promise.all([tmdbFetch(movieUrl), tmdbFetch(tvUrl)]);
    const movies = Array.isArray(pair[0].results) ? pair[0].results : [];
    const tv = Array.isArray(pair[1].results) ? pair[1].results : [];

    for (let i = 0; i < movies.length; i++) movies[i].media_type = "movie";
    for (let i = 0; i < tv.length; i++) tv[i].media_type = "tv";

    const merged = movies.concat(tv);
    merged.sort(function (a, b) { return (b.popularity || 0) - (a.popularity || 0); });

          if (state.mood && state.mood !== "any") {
            const mf = [];
            for (let i = 0; i < merged.length; i++) {
              if (moodMatchesTmdb(merged[i])) mf.push(merged[i]);
            }
            merged = mf;
          }

    state.forYouResults = merged.slice(0, 40);
    state.forYouLoaded = true;
    cacheSet("rq_cache_forYou", { results: state.forYouResults, meta: { country: state.country, favouriteGenres: state.favouriteGenres, includeTv: state.includeTv } });
  } catch (err) {
    console.error(err);
    state.forYouResults = [];
    state.forYouLoaded = false;
    els.message.textContent = "We couldn‚Äôt load popular titles. Please check your connection.";
  } finally {
    state.forYouLoading = false;
    render();
  }
}

      async function performDiscoverSearch() {
        const query = state.searchTerm ? state.searchTerm.trim() : "";
        if (!query) {
          await loadPopularForDiscover();
          return;
        }
        els.message.style.display = "block";
        els.message.textContent = "Searching TMDB‚Ä¶";
        renderSkeletonGrid(10);
        try {
          const results = await searchTmdb(query);
          state.discoverResults = results;
        } catch (err) {
          console.error(err);
          state.discoverResults = [];
          els.message.textContent =
            "TMDB search failed. Please check your connection.";
        } finally {
          render();
        }
      }

      async function loadForYouRecommendations() {
  if (!state.favouriteGenres.length) {
    state.forYouLoading = true;
    state.forYouLoaded = false;
    loadForYouFallbackPopular();
    return;
  }

  state.forYouLoading = true;
  state.forYouLoaded = false;
  els.message.style.display = "block";
  els.message.textContent =
    "Fetching recommendations based on your favourite genres‚Ä¶";
  els.grid.innerHTML = "";

  try {
    // Movie genre IDs
    const ids = [];
    for (let i = 0; i < MOVIE_GENRES.length; i++) {
      if (state.favouriteGenres.indexOf(MOVIE_GENRES[i].name) !== -1) {
        ids.push(MOVIE_GENRES[i].id);
      }
    }
    const genreCsv = ids.join(",");

    const movieUrl = new URL("https://api.themoviedb.org/3/discover/movie");
    movieUrl.searchParams.set("api_key", TMDB_API_KEY);
    movieUrl.searchParams.set("include_adult", "false");
    movieUrl.searchParams.set("language", "en-GB");
    movieUrl.searchParams.set("sort_by", "popularity.desc");
    movieUrl.searchParams.set("with_genres", genreCsv);
    movieUrl.searchParams.set("page", "1");

    if (!state.includeTv) {
      const data = await tmdbFetch(movieUrl);
      const res = Array.isArray(data.results) ? data.results : [];
      for (let i = 0; i < res.length; i++) res[i].media_type = "movie";
      state.forYouResults = res;
      state.forYouLoaded = true;
      cacheSet("rq_cache_forYou", { results: state.forYouResults, meta: { country: state.country, favouriteGenres: state.favouriteGenres, includeTv: state.includeTv } });
      render();
      return;
    }

    // Map selected genre names to TV genre IDs (best-effort)
    const tvIds = [];
    for (let i = 0; i < state.favouriteGenres.length; i++) {
      const name = state.favouriteGenres[i];
      if (TV_GENRE_IDS_BY_NAME[name]) tvIds.push(TV_GENRE_IDS_BY_NAME[name]);
    }
    const tvCsv = tvIds.join(",");

    const tvUrl = new URL("https://api.themoviedb.org/3/discover/tv");
    tvUrl.searchParams.set("api_key", TMDB_API_KEY);
    tvUrl.searchParams.set("language", "en-GB");
    tvUrl.searchParams.set("sort_by", "popularity.desc");
    if (tvCsv) tvUrl.searchParams.set("with_genres", tvCsv);
    tvUrl.searchParams.set("page", "1");

    const pair = await Promise.all([tmdbFetch(movieUrl), tmdbFetch(tvUrl)]);
    const movies = Array.isArray(pair[0].results) ? pair[0].results : [];
    const tv = Array.isArray(pair[1].results) ? pair[1].results : [];

    for (let i = 0; i < movies.length; i++) movies[i].media_type = "movie";
    for (let i = 0; i < tv.length; i++) tv[i].media_type = "tv";

    const merged = movies.concat(tv);
    merged.sort(function (a, b) { return (b.popularity || 0) - (a.popularity || 0); });

          if (state.mood && state.mood !== "any") {
            const mf = [];
            for (let i = 0; i < merged.length; i++) {
              if (moodMatchesTmdb(merged[i])) mf.push(merged[i]);
            }
            merged = mf;
          }

    state.forYouResults = merged.slice(0, 40);
    state.forYouLoaded = true;
    cacheSet("rq_cache_forYou", { results: state.forYouResults, meta: { country: state.country, favouriteGenres: state.favouriteGenres, includeTv: state.includeTv } });
  } catch (err) {
    const cached = cacheGet("rq_cache_forYou", 1000 * 60 * 60 * 24 * 21);
    if (cached && Array.isArray(cached.results) && cached.results.length) {
      state.forYouResults = cached.results;
      state.forYouLoaded = true;
      els.message.style.display = "block";
      els.message.textContent = "Offline ‚Äî showing your last saved recommendations.";
      state.forYouLoading = false;
      render();
      return;
    }
    console.error(err);
    state.forYouResults = [];
    state.forYouLoaded = false;
    els.message.textContent =
      "We couldn‚Äôt load your recommendations. Please check your connection.";
  } finally {
    state.forYouLoading = false;
    render();
  }
}

      function findItemByTmdbId(tmdbId, mediaType) {
  const mt = normaliseMediaType(mediaType);
  const want = toTmdbId(tmdbId);
  if (want === null) return null;

  // First pass: exact match (tmdbId + media type)
  let otherMatch = null;
  let otherCount = 0;

  for (let i = 0; i < state.items.length; i++) {
    const it = state.items[i];
    const have = toTmdbId(it.tmdbId);
    if (have === null || have !== want) continue;

    const itType = normaliseMediaType(it.mediaType || "movie");
    if (itType === mt) return it;

    // Track mismatched-type matches in case we can safely heal legacy data
    otherMatch = it;
    otherCount += 1;
  }

  // If there's exactly one item with this tmdbId (but wrong type), heal it to the expected type.
  // This avoids the "status only shows for some titles" issue caused by older saves that defaulted TV->movie.
  if (otherMatch && otherCount === 1) {
    const cur = normaliseMediaType(otherMatch.mediaType || "movie");
    if (cur !== mt) {
      otherMatch.mediaType = mt;
      saveState();
    }
    return otherMatch;
  }

  return null;
}
// Link a remote TMDB result to an existing saved item more reliably.
// This fixes "status only shows on some random titles" caused by:
// - TMDB TV results often missing `media_type`
// - legacy saves with wrong mediaType
// - rare TMDB ID collisions between movie and TV namespaces
function normaliseTitleForMatch(t) {
  return String(t || "")
    .toLowerCase()
    .replace(/[\W_]+/g, "")
    .trim();
}

function linkSavedItemFromTmdb(obj, fallbackType) {
  const id = toTmdbId(obj && obj.id);
  if (id === null) return null;

  const mt = inferMediaTypeFromTmdb(obj || {}, fallbackType || "movie");
  const matches = [];
  for (let i = 0; i < state.items.length; i++) {
    const it = state.items[i];
    const have = toTmdbId(it.tmdbId);
    if (have === null || have !== id) continue;
    matches.push(it);
  }
  if (!matches.length) return null;

  // Prefer exact type match
  for (let i = 0; i < matches.length; i++) {
    const it = matches[i];
    const itType = normaliseMediaType(it.mediaType || "movie");
    if (itType === mt) return it;
  }

  // If there's only one match, heal the media type
  if (matches.length === 1) {
    const it = matches[0];
    const cur = normaliseMediaType(it.mediaType || "movie");
    if (cur !== mt) {
      it.mediaType = mt;
      saveState();
    }
    return it;
  }

  // Collision: choose best title match (no healing)
  const wantTitle = normaliseTitleForMatch(titleFromTmdb(obj));
  if (wantTitle) {
    let best = null;
    let bestScore = -1;
    let bestCount = 0;

    for (let i = 0; i < matches.length; i++) {
      const it = matches[i];
      const haveTitle = normaliseTitleForMatch(it.title);
      let score = 0;
      if (haveTitle && haveTitle === wantTitle) score = 100;
      else if (haveTitle && (haveTitle.includes(wantTitle) || wantTitle.includes(haveTitle))) score = 50;

      if (score > bestScore) {
        bestScore = score;
        best = it;
        bestCount = 1;
      } else if (score === bestScore) {
        bestCount += 1;
      }
    }

    if (best && bestScore > 0 && bestCount === 1) return best;
  }

  return matches[0];
}




function ensureItemFromTmdb(tmdbObj, mediaType) {
  // Always infer from the TMDB object when possible, so wrong/missing `media_type` doesn't create duplicates.
  const mt = normaliseMediaType(inferMediaTypeFromTmdb(tmdbObj || {}, mediaType || (tmdbObj && tmdbObj.media_type) || "movie"));
  const existing = findItemByTmdbId(tmdbObj.id, mt);
  if (existing) return existing;

  // Legacy healing: if we previously saved a TV show as a movie (or vice versa),
  // reuse the existing item and correct its mediaType.
  const want = toTmdbId(tmdbObj && tmdbObj.id);
  if (want !== null) {
    for (let i = 0; i < state.items.length; i++) {
      const it = state.items[i];
      const have = toTmdbId(it.tmdbId);
      if (have !== null && have === want) {
        const cur = normaliseMediaType(it.mediaType || "movie");
        if (cur !== mt) {
          it.mediaType = mt;
          saveState();
        }
        return it;
      }
    }
  }
const now = Date.now();
  const item = {
    id: safeId(),
    tmdbId: tmdbObj.id,
    mediaType: mt,
    title: titleFromTmdb(tmdbObj),
    year: yearFromTmdb(tmdbObj),
    posterPath: tmdbObj.poster_path || null,
    rating: typeof tmdbObj.vote_average === "number" ? tmdbObj.vote_average : null,

    // Lists/workflow
    inWatchlist: false,
    watched: false,
    watchedAt: null,
    userRating: null,
    rewatch: false,
    priority: "medium",
    tags: [],
    notes: "",

    createdAt: now,
    addedAt: now
  };

  state.items.push(item);
  saveState();
  return item;
}


function toggleWatchlistForItem(item) {
  const was = !!item.inWatchlist;

  if (!was) {
    item.inWatchlist = true;
    if (!item.priority) item.priority = "medium";
    item.status = normaliseWatchStatus(item.status);
    saveState();
    render();
    toast("Added to your watchlist.");
    return;
  }

  // Removing from watchlist ‚Äî clear any in-progress status (with undo)
  const prevStatus = item.status;
  item.inWatchlist = false;
  item.status = null;

  saveState();
  render();
  toast("Removed from your watchlist.", {
    actionText: "Undo",
    onAction: function () {
      item.inWatchlist = true;
      if (!item.priority) item.priority = "medium";
      item.status = normaliseWatchStatus(prevStatus);
      saveState();
      render();
    }
  });
}


function toggleWatchedForItem(item) {
  const was = !!item.watched;

  if (!was) {
    item.watched = true;
    // When something is watched, it typically leaves the watchlist
    item.inWatchlist = false;
    item.status = null;
    // Rewatch only makes sense if watched, but default off on first mark
    item.rewatch = false;

    if (!item.watchedAt) item.watchedAt = Date.now();

    saveState();
    render();
    toast("Marked as watched.");
    return;
  }

  // Unwatch (with undo)
  const prev = {
    watchedAt: (typeof item.watchedAt === "number") ? item.watchedAt : null,
    userRating: (typeof item.userRating === "number") ? item.userRating : null,
    inWatchlist: !!item.inWatchlist,
    rewatch: !!item.rewatch
  };

  item.watched = false;
  item.rewatch = false;
  item.watchedAt = null;
  item.userRating = null;

  saveState();
  render();

  toast("Marked as not watched.", {
    actionText: "Undo",
    onAction: function () {
      item.watched = true;
      item.watchedAt = prev.watchedAt || Date.now();
      item.userRating = prev.userRating;
      item.inWatchlist = prev.inWatchlist;
      item.rewatch = prev.rewatch;
      saveState();
      render();
    }
  });
}


function clearWatched() {
        if (!window.confirm("Clear everything marked as watched?")) {
          return;
        }
        for (let i = 0; i < state.items.length; i++) {
          if (state.items[i].watched) {
            state.items[i].watched = false;
          }
        }
        saveState();
        render();
      }

      function shareWatchlist() {
        const watchlist = [];
        for (let i = 0; i < state.items.length; i++) {
          const it = state.items[i];
          if (it.inWatchlist) watchlist.push(it);
        }

        if (!watchlist.length) {
          alertNice("Your watchlist is empty.");
          return;
        }

        watchlist.sort(function (a, b) {
          const ta = (a.title || "").toLowerCase();
          const tb = (b.title || "").toLowerCase();
          if (ta < tb) return -1;
          if (ta > tb) return 1;
          return 0;
        });

        const lines = [];
        for (let i = 0; i < watchlist.length; i++) {
          const it = watchlist[i];
          const n = i + 1;
          const title = it.title || "Untitled";
          const year = it.year ? " (" + it.year + ")" : "";
          const watched = it.watched ? " ¬∑ watched" : "";
          lines.push(n + ". " + title + year + watched);
        }

        const finalText = "My ReelQuest watchlist:\n\n" + lines.join("\n") + "\n\nShared from ReelQuest.";

        if (navigator.share) {
          navigator.share({ title: "My ReelQuest watchlist", text: finalText }).catch(function () {});
        } else if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(finalText)
            .then(function () { alertNice("Watchlist copied to the clipboard."); })
            .catch(function () {
              alertNice("Couldn‚Äôt access the clipboard, but here‚Äôs your list:\n\n" + finalText);
            });
        } else {
          alertNice(finalText);
        }
      }

function base64UrlEncodeUtf8(str) {
  // UTF-8 -> base64url
  const b64 = btoa(unescape(encodeURIComponent(str)));
  return b64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
}

function base64UrlDecodeUtf8(b64url) {
  // base64url -> UTF-8
  const b64 = String(b64url || "").replace(/-/g, "+").replace(/_/g, "/");
  const padded = b64 + "===".slice((b64.length + 3) % 4);
  return decodeURIComponent(escape(atob(padded)));
}

function slugifyFilename(name) {
  return String(name || "list")
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-+|-+$/g, "")
    .slice(0, 40) || "list";
}

function buildListExportPayload(list) {
  // Export just one list, but keep enough metadata to re-import safely.
  return {
    app: "ReelQuest",
    kind: "list",
    version: 1,
    exportedAt: new Date().toISOString(),
    list: list
  };
}

function downloadJson(filename, obj) {
  const json = JSON.stringify(obj, null, 2);
  const blob = new Blob([json], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  setTimeout(function () { URL.revokeObjectURL(url); }, 250);
}

function exportSingleListToFile(listId) {
  const list = getListById(listId);
  if (!list) return;
  const payload = buildListExportPayload(list);

  const stamp = new Date();
  const yyyy = stamp.getFullYear();
  const mm = String(stamp.getMonth() + 1).padStart(2, "0");
  const dd = String(stamp.getDate()).padStart(2, "0");
  const filename = "reelquest-list-" + slugifyFilename(list.name) + "-" + yyyy + "-" + mm + "-" + dd + ".json";

  downloadJson(filename, payload);
  toast("Exported ‚Äú" + (list.name || "List") + "‚Äù.");
}

function ensureUniqueListName(name) {
  const base = String(name || "Untitled list").trim() || "Untitled list";
  let candidate = base;
  let n = 2;
  function existsTitle(t) {
    for (let i = 0; i < state.lists.length; i++) {
      if ((state.lists[i].name || "").trim().toLowerCase() === t.trim().toLowerCase()) return true;
    }
    return false;
  }
  while (existsTitle(candidate)) {
    candidate = base + " (" + n + ")";
    n++;
  }
  return candidate;
}

function mergeListEntries(targetList, incomingList) {
  if (!targetList || !incomingList) return;

  // Only manual lists get entry-level merges.
  if (targetList.type !== "manual" || incomingList.type !== "manual") return;

  const exists = {};
  for (let i = 0; i < targetList.entries.length; i++) {
    const e = targetList.entries[i];
    exists[entryKey(e.mediaType || "movie", e.tmdbId)] = true;
  }

  for (let i = 0; i < incomingList.entries.length; i++) {
    const e = incomingList.entries[i];
    const key = entryKey(e.mediaType || "movie", e.tmdbId);
    if (exists[key]) continue;
    targetList.entries.push({
      tmdbId: e.tmdbId,
      mediaType: normaliseMediaType(e.mediaType || "movie"),
      title: e.title || "Untitled",
      year: e.year || "",
      posterPath: e.posterPath || null,
      rating: typeof e.rating === "number" ? e.rating : null,
      addedAt: typeof e.addedAt === "number" ? e.addedAt : Date.now()
    });
    exists[key] = true;
  }

  ensureCustomOrder(targetList);
}

function importSingleListObject(obj, mode) {
  // mode: "add" (default) | "merge"
  const imported = obj && obj.list ? obj.list : null;
  if (!imported || typeof imported !== "object") {
    alertNice("That file doesn‚Äôt contain a list.");
    return;
  }

  const lists = normaliseImportedLists([imported]);
  if (!lists.length) {
    alertNice("That list couldn‚Äôt be imported.");
    return;
  }

  const incoming = lists[0];

  if (mode === "merge") {
    // Merge by list id first, then by title (manual only).
    let target = null;

    for (let i = 0; i < state.lists.length; i++) {
      if (state.lists[i].id === incoming.id) { target = state.lists[i]; break; }
    }

    if (!target) {
      const incomingName = (incoming.name || "").trim().toLowerCase();
      for (let i = 0; i < state.lists.length; i++) {
        const existing = state.lists[i];
        if ((existing.name || "").trim().toLowerCase() === incomingName && existing.type === incoming.type) {
          target = existing;
          break;
        }
      }
    }

    if (target) {
      // Only merge entries for manual lists. For others, keep existing.
      mergeListEntries(target, incoming);
      saveState();
      toast("Merged into ‚Äú" + (target.name || "List") + "‚Äù.");
      // Jump to list
      openListDetail(target.id);
      return;
    }
  }

  // Add as a new list (default)
  incoming.id = safeId();
  incoming.name = ensureUniqueListName(incoming.name || "Untitled list");
  incoming.pinned = false;
  if (!Array.isArray(incoming.entries)) incoming.entries = [];
  if (!incoming.type) incoming.type = "manual";
  if (!incoming.sortMode) incoming.sortMode = "custom";
  if (!Array.isArray(incoming.customOrder)) incoming.customOrder = [];

  ensureCustomOrder(incoming);
  state.lists.push(incoming);
  saveState();
  toast("Imported ‚Äú" + (incoming.name || "List") + "‚Äù.");
  openListDetail(incoming.id);
}

function pickAndImportSingleList() {
  const temp = document.createElement("input");
  temp.type = "file";
  temp.accept = ".json,application/json";
  temp.style.display = "none";
  document.body.appendChild(temp);

  temp.addEventListener("change", function () {
    const files = temp.files;
    if (!files || !files[0]) {
      document.body.removeChild(temp);
      return;
    }
    const file = files[0];

    const wantMerge = window.confirm("Merge this list into an existing list if it matches?\n\nOK = Merge\nCancel = Add as a new list");

    const reader = new FileReader();
    reader.onload = function () {
      try {
        const parsed = JSON.parse(String(reader.result || ""));
        importSingleListObject(parsed, wantMerge ? "merge" : "add");
      } catch (e) {
        alertNice("Sorry ‚Äî we couldn‚Äôt read that file.");
      } finally {
        document.body.removeChild(temp);
      }
    };
    reader.onerror = function () {
      alertNice("Sorry ‚Äî we couldn‚Äôt read that file.");
      document.body.removeChild(temp);
    };
    reader.readAsText(file);
  });

  temp.click();
}

function buildListShareText(list) {
  const lines = [];
  const entries = [];

  if (list && list.type === "manual") {
    for (let i = 0; i < list.entries.length; i++) entries.push(list.entries[i]);
  }

  for (let i = 0; i < entries.length; i++) {
    const e = entries[i];
    const title = e.title || "Untitled";
    const y = e.year ? " (" + e.year + ")" : "";
    const tv = normaliseMediaType(e.mediaType || "movie") === "tv" ? " [TV]" : "";
    lines.push((i + 1) + ". " + title + y + tv);
  }

  const header = "ReelQuest ‚Äî " + (list.name || "List");
  const desc = list.description ? ("\n" + list.description.trim()) : "";
  const body = lines.length ? ("\n\n" + lines.join("\n")) : "\n\n(Empty list)";
  return header + desc + body + "\n\nShared from ReelQuest.";
}

function buildListShareLink(list) {
  // Encode a single list payload into the URL. This can get long for huge lists.
  const payload = buildListExportPayload(list);
  const encoded = base64UrlEncodeUtf8(JSON.stringify(payload));
  const url = new URL(window.location.href);
  url.searchParams.set("share", encoded);
  return url.toString();
}

function copyToClipboardFallback(text) {
  const ta = document.createElement("textarea");
  ta.value = text;
  ta.setAttribute("readonly", "readonly");
  ta.style.position = "fixed";
  ta.style.left = "-9999px";
  ta.style.top = "0";
  document.body.appendChild(ta);
  ta.select();
  try { document.execCommand("copy"); } catch (e) {}
  document.body.removeChild(ta);
}

async function copyToClipboard(text) {
  try {
    if (navigator.clipboard && navigator.clipboard.writeText) {
      await navigator.clipboard.writeText(text);
      return true;
    }
  } catch (e) {}
  copyToClipboardFallback(text);
  return true;
}

async function shareList(listId) {
  const list = getListById(listId);
  if (!list) return;

  const wantLink = window.confirm("Share a link that opens this list in ReelQuest?\n\nOK = Share link\nCancel = Share text card");

  if (wantLink) {
    const link = buildListShareLink(list);
    const title = "ReelQuest ‚Äî " + (list.name || "List");
    const text = "Here‚Äôs a ReelQuest list: ‚Äú" + (list.name || "List") + "‚Äù.";
    if (navigator.share) {
      try {
        await navigator.share({ title: title, text: text, url: link });
        return;
      } catch (e) {
        // fall through to copy
      }
    }
    await copyToClipboard(link);
    toast("Link copied to clipboard.");
    return;
  }

  const card = buildListShareText(list);
  const title = "ReelQuest ‚Äî " + (list.name || "List");
  if (navigator.share) {
    try {
      await navigator.share({ title: title, text: card });
      return;
    } catch (e) {}
  }
  await copyToClipboard(card);
  toast("Text card copied to clipboard.");
}

function handleIncomingSharedList() {
  try {
    const url = new URL(window.location.href);
    const param = url.searchParams.get("share");
    if (!param) return;

    const decoded = base64UrlDecodeUtf8(param);
    const parsed = JSON.parse(decoded);

    const ok = window.confirm("This link contains a shared ReelQuest list. Do you want to import it?\n\nOK = Import\nCancel = Ignore");
    if (!ok) {
      url.searchParams.delete("share");
      window.history.replaceState({}, document.title, url.toString());
      return;
    }

    const wantMerge = window.confirm("Merge into an existing list if it matches?\n\nOK = Merge\nCancel = Add as a new list");

    importSingleListObject(parsed, wantMerge ? "merge" : "add");

    // Clean the URL so refreshing doesn‚Äôt re-import
    url.searchParams.delete("share");
    window.history.replaceState({}, document.title, url.toString());
  } catch (e) {
    console.warn("Failed to import shared list:", e);
  }
}




async function pickFromWatchlist() {
  // Build watchlist views (local) and apply current filters/search
  const views = getViewItemsForCurrentTab();
  const candidates = [];
  for (let i = 0; i < views.length; i++) {
    const v = views[i];
    if (v && v.item && v.item.inWatchlist && !v.item.watched) {
      candidates.push(v);
    }
  }

  if (!candidates.length) {
    alertNice("No eligible films in your watchlist with the current filters.");
    return;
  }

  // Try to avoid repeating the last pick if possible
  let pick = null;
  if (candidates.length === 1) {
    pick = candidates[0];
  } else {
    for (let tries = 0; tries < 10; tries++) {
      const v = candidates[Math.floor(Math.random() * candidates.length)];
      if (!state.lastPickTmdbId || toTmdbId(v.item.tmdbId) !== state.lastPickTmdbId) {
        pick = v;
        break;
      }
    }
    if (!pick) pick = candidates[Math.floor(Math.random() * candidates.length)];
  }

  state.lastPickTmdbId = toTmdbId(pick.item.tmdbId);
  saveState();
  openDetailForView(pick);
}

      function ratingFromView(view) {
        if (view.mode === "local") {
          return typeof view.item.rating === "number" ? view.item.rating : 0;
        }
        if (view.tmdbMovie && typeof view.tmdbMovie.vote_average === "number") {
          return view.tmdbMovie.vote_average;
        }
        return 0;
      }

      function yearFromView(view) {
        if (view.mode === "local") {
          return view.item.year ? parseInt(view.item.year, 10) || 0 : 0;
        }
        if (view.tmdbMovie && view.tmdbMovie.release_date) {
          return parseInt(view.tmdbMovie.release_date.slice(0, 4), 10) || 0;
        }
        return 0;
      }

      function popularityFromView(view) {
        if (view.tmdbMovie && typeof view.tmdbMovie.popularity === "number") {
          return view.tmdbMovie.popularity;
        }
        return view.item && view.item.createdAt ? view.item.createdAt : 0;
      }

      function titleFromView(view) {
        if (view.mode === "local") {
          return (view.item.title || "").toLowerCase();
        }
        if (view.tmdbMovie) {
          return (view.tmdbMovie.title || "").toLowerCase();
        }
        return "";
      }

      function applyFiltersAndSort(views) {
        const min = state.minRating || 0;
        let filtered = views;

        if (min > 0) {
          const temp = [];
          for (let i = 0; i < filtered.length; i++) {
            if (ratingFromView(filtered[i]) >= min) {
              temp.push(filtered[i]);
            }
          }
          filtered = temp;
        }


        // Mood filter (works for remote results and local lists; local uses cached TMDB details)
        const moodKey = getMoodKey();
        if (moodKey !== "any") {
          const tmpMood = [];
          for (let i = 0; i < filtered.length; i++) {
            const v = filtered[i];
            if (v && v.tmdbMovie) {
              if (moodMatchesTmdb(v.tmdbMovie)) tmpMood.push(v);
              continue;
            }
            if (v && v.item) {
              const id = toTmdbId(v.item.tmdbId);
              if (id !== null) {
                const mt = normaliseMediaType(v.item.mediaType || v.mediaType || "movie");
                const cacheKey = mt + ":" + id;
                const det = state.detailsCache ? state.detailsCache[cacheKey] : null;
                if (!det) continue; // no genre info yet ‚Äî will be populated by ensureDetailsForLocalTab()
                const obj = Object.assign({ media_type: mt }, det);
                if (moodMatchesTmdb(obj)) tmpMood.push(v);
                continue;
              }
            }
            // Fallback: keep the item
            tmpMood.push(v);
          }
          filtered = tmpMood;
        }

        // Extra filters
        const minYear = state.filters && typeof state.filters.minYear === "number" ? state.filters.minYear : 0;
        const hideWatchedRaw = state.filters ? !!state.filters.hideWatched : false;
        const hideWatchlistRaw = state.filters ? !!state.filters.hideWatchlist : false;
        const excludedGenres = state.filters && Array.isArray(state.filters.excludedGenres) ? state.filters.excludedGenres : [];
        // Important: don't hide items *within* their own tabs
        const tab = state.activeTab;
        const hideWatched = hideWatchedRaw && !(tab === "watched" || tab === "rewatch");
        const hideWatchlist = hideWatchlistRaw && !(tab === "watchlist");

        if (minYear || hideWatched || hideWatchlist || (excludedGenres && excludedGenres.length)) {
          const temp2 = [];
          for (let i = 0; i < filtered.length; i++) {
            const v = filtered[i];

            // Hide watched/watchlist based on linked local item if present.
            // These toggles are meant to hide titles *from other tabs* (Discover/For You/etc),
            // not from their own list tabs.
            if (hideWatched && state.activeTab !== "watched" && state.activeTab !== "rewatch" && v.item && v.item.watched) continue;
            if (hideWatchlist && state.activeTab !== "watchlist" && v.item && v.item.inWatchlist) continue;

            if (minYear) {
              const y = yearFromView(v);
              if (y && y < minYear) continue;
            }

            if (excludedGenres && excludedGenres.length && v.tmdbMovie && Array.isArray(v.tmdbMovie.genre_ids)) {
              let blocked = false;
              for (let g = 0; g < v.tmdbMovie.genre_ids.length; g++) {
                if (excludedGenres.indexOf(v.tmdbMovie.genre_ids[g]) !== -1) {
                  blocked = true;
                  break;
                }
              }
              if (blocked) continue;
            }

            temp2.push(v);
          }
          filtered = temp2;
        }

        const sorted = filtered.slice();

        if (state.sortBy !== "default") {
        if (state.sortBy === "title-asc") {
          sorted.sort(function (a, b) {
            return titleFromView(a).localeCompare(titleFromView(b));
          });
        } else if (state.sortBy === "year-desc") {
          sorted.sort(function (a, b) {
            return yearFromView(b) - yearFromView(a);
          });
        } else if (state.sortBy === "rating-desc") {
          sorted.sort(function (a, b) {
            return ratingFromView(b) - ratingFromView(a);
          });
        } else if (state.sortBy === "priority") {
          sorted.sort(function (a, b) {
            function score(v) {
              const it = v && v.item ? v.item : null;
              const p = it && typeof it.priority === "string" ? it.priority : "";
              if (p === "high") return 3;
              if (p === "medium") return 2;
              if (p === "low") return 1;
              return 0;
            }
            const ds = score(b) - score(a);
            if (ds !== 0) return ds;
            // tie-break by title
            const at = titleFromView(a);
            const bt = titleFromView(b);
            return String(at).localeCompare(String(bt), "en-GB");
          });
        } else if (state.sortBy === "popularity-desc") {
          sorted.sort(function (a, b) {
            return popularityFromView(b) - popularityFromView(a);
          });
        }
        }


        const pref = streamingPref();
        if (pref !== "any") {
          const available = [];
          const unknown = [];
          const unavailable = [];
          for (let i = 0; i < sorted.length; i++) {
            const v = sorted[i];
            const f = streamingFlagForView(v);
            if (f === true) available.push(v);
            else if (f === false) unavailable.push(v);
            else unknown.push(v);
          }
          if (pref === "only") return available.concat(unknown);
          return available.concat(unknown, unavailable);
        }

        return sorted;
      }

      function getViewItemsForCurrentTab() {
        const term = state.searchTerm
          ? state.searchTerm.trim().toLowerCase()
          : "";

        if (state.activeTab === "radar") {
          const term = state.searchTerm ? state.searchTerm.trim().toLowerCase() : "";
          let raw = state.radarResults || [];
          if (term) {
            const filtered = [];
            for (let i = 0; i < raw.length; i++) {
              const m = raw[i];
              const t = (titleFromTmdb(m) || "").toLowerCase();
              if (t.indexOf(term) !== -1) filtered.push(m);
            }
            raw = filtered;
          }
          const views = [];
          for (let i = 0; i < raw.length; i++) {
            const m = raw[i];
            const mt = inferMediaTypeFromTmdb(m, "movie");
const linked = linkSavedItemFromTmdb(m, mt);
views.push({ mode: "remote", tmdbMovie: m, item: linked, mediaType: mt });
}
          return applyFiltersAndSort(views);
        }

        if (state.activeTab === "discover") {
          let raw = state.discoverResults || [];
          if (term) {
            const filtered = [];
            for (let i = 0; i < raw.length; i++) {
              const m = raw[i];
              const t = (titleFromTmdb(m) || "").toLowerCase();
              if (t.indexOf(term) !== -1) filtered.push(m);
            }
            raw = filtered;
          }
          const views = [];
          for (let i = 0; i < raw.length; i++) {
            const m = raw[i];
            const mt = inferMediaTypeFromTmdb(m, "movie");
const linked = linkSavedItemFromTmdb(m, mt);
views.push({ mode: "remote", tmdbMovie: m, item: linked, mediaType: mt });
}
          return applyFiltersAndSort(views);
        }

        if (state.activeTab === "for-you") {
          let base = state.forYouResults || [];
          if (term) {
            const filtered = [];
            for (let i = 0; i < base.length; i++) {
              const m = base[i];
              const t = (titleFromTmdb(m) || "").toLowerCase();
              if (t.indexOf(term) !== -1) filtered.push(m);
            }
            base = filtered;
          }
          const views = [];
          for (let i = 0; i < base.length; i++) {
            const m = base[i];
            const mt = inferMediaTypeFromTmdb(m, "movie");
const linked = linkSavedItemFromTmdb(m, mt);
views.push({ mode: "remote", tmdbMovie: m, item: linked, mediaType: mt });
}
          return applyFiltersAndSort(views);
        }

        const base = state.items.slice().sort(function (a, b) {
          const ca = a.createdAt || 0;
          const cb = b.createdAt || 0;
          return cb - ca;
        });

        let filteredItems;
        if (state.activeTab === "watchlist") {
          const tmp = [];
          for (let i = 0; i < base.length; i++) {
            if (base[i].inWatchlist && !base[i].watched) tmp.push(base[i]);
          }
          filteredItems = tmp;
        } else if (state.activeTab === "rewatch") {
          const tmp = [];
          for (let i = 0; i < base.length; i++) {
            if (base[i].rewatch) tmp.push(base[i]);
          }
          filteredItems = tmp;
        } else if (state.activeTab === "watched") {
          const tmp = [];
          for (let i = 0; i < base.length; i++) {
            if (base[i].watched) tmp.push(base[i]);
          }
          filteredItems = tmp;
        } else {
          filteredItems = [];
        }

        if (term) {
          const tmp2 = [];
          for (let i = 0; i < filteredItems.length; i++) {
            const it = filteredItems[i];
            const t = (it.title || "").toLowerCase();
            if (t.indexOf(term) !== -1) tmp2.push(it);
          }
          filteredItems = tmp2;
        }

        const views = [];
        for (let i = 0; i < filteredItems.length; i++) {
          views.push({ mode: "local", item: filteredItems[i], tmdbMovie: null });
        }
        return applyFiltersAndSort(views);
      }

      function toggleFavouriteGenre(id) {
        const idx = state.favouriteGenres.indexOf(id);
        if (idx === -1) {
          state.favouriteGenres.push(id);
        } else {
          state.favouriteGenres.splice(idx, 1);
        }
        saveState();
        renderSettings();
        if (state.activeTab === "for-you") {
          loadForYouRecommendations();
        }
      }

      function renderSettings() {
        const panel = els.settingsPanel;
        panel.innerHTML = "";

        const heading = document.createElement("h2");
        heading.className = "settings-heading";
        heading.textContent = "Preferences";

        const copy = document.createElement("p");
        copy.className = "settings-copy";
        copy.textContent =
          "Tell ReelQuest which genres you love. We‚Äôll use this for smarter suggestions later.";

        const sub = document.createElement("div");
        sub.className = "settings-subheading";
        sub.textContent = "Favourite genres";

        const grid = document.createElement("div");
        grid.className = "genre-grid";

        const selected = {};
        for (let i = 0; i < state.favouriteGenres.length; i++) {
          selected[state.favouriteGenres[i]] = true;
        }

        for (let i = 0; i < GENRES.length; i++) {
          const genre = GENRES[i];
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "genre-pill";
          if (selected[genre.id]) {
            btn.classList.add("active");
          }
          btn.textContent = genre.name;
          btn.addEventListener("click", function () {
            toggleFavouriteGenre(genre.id);
          });
          grid.appendChild(btn);
        }

        panel.appendChild(heading);
        panel.appendChild(copy);

// App
const appHeading = document.createElement("div");
appHeading.className = "settings-subheading";
appHeading.style.marginTop = "14px";
appHeading.textContent = "App";

const appCopy = document.createElement("p");
appCopy.className = "settings-copy";
appCopy.textContent = "Install ReelQuest to your Home Screen for an app-like experience. Offline, you‚Äôll still see your last saved results.";

const appRow = document.createElement("div");
appRow.style.display = "flex";
appRow.style.flexWrap = "wrap";
appRow.style.gap = "10px";
appRow.style.alignItems = "center";

const installBtn = document.createElement("button");
installBtn.type = "button";
installBtn.className = "pill-btn";
installBtn.textContent = "Install ReelQuest";
installBtn.addEventListener("click", function () {
  showInstallHint();
});

const offlineNote = document.createElement("span");
offlineNote.style.fontSize = "12px";
offlineNote.style.color = "var(--text-muted)";
offlineNote.textContent = (isOffline() ? "Status: Offline" : "Status: Online");

const clearOfflineBtn = document.createElement("button");
clearOfflineBtn.type = "button";
clearOfflineBtn.className = "pill-btn";
clearOfflineBtn.textContent = "Remove offline support";
clearOfflineBtn.addEventListener("click", function () {
  unregisterServiceWorkersAndClearCaches();
  toast("Offline support removed. Reloading‚Ä¶");
  setTimeout(function(){ location.href = location.pathname + "?v=26"; }, 600);
});

appRow.appendChild(installBtn);
appRow.appendChild(offlineNote);
appRow.appendChild(clearOfflineBtn);

panel.appendChild(appHeading);
panel.appendChild(appCopy);
panel.appendChild(appRow);

        const countryHeading = document.createElement("div");
        countryHeading.className = "settings-subheading";
        countryHeading.style.marginTop = "12px";
        countryHeading.textContent = "Country";

        const countryCopy = document.createElement("p");
        countryCopy.className = "settings-copy";
        countryCopy.textContent = "Used for ‚ÄúWhere to watch‚Äù availability and Radar releases.";

        const countryRow = document.createElement("div");
        countryRow.style.display = "flex";
        countryRow.style.flexWrap = "wrap";
        countryRow.style.gap = "10px";
        countryRow.style.alignItems = "center";

        const countrySelect = document.createElement("select");
        countrySelect.className = "controls-select";
        countrySelect.style.borderRadius = "14px";
        countrySelect.style.padding = "8px 12px";

        const COUNTRIES = [
          ["GB", "United Kingdom"],
          ["IE", "Ireland"],
          ["US", "United States"],
          ["CA", "Canada"],
          ["AU", "Australia"],
          ["NZ", "New Zealand"],
          ["FR", "France"],
          ["DE", "Germany"],
          ["ES", "Spain"],
          ["IT", "Italy"],
          ["NL", "Netherlands"],
          ["SE", "Sweden"],
          ["NO", "Norway"],
          ["DK", "Denmark"],
          ["FI", "Finland"],
          ["BE", "Belgium"],
          ["CH", "Switzerland"]
        ];

        for (let i = 0; i < COUNTRIES.length; i++) {
          const opt = document.createElement("option");
          opt.value = COUNTRIES[i][0];
          opt.textContent = COUNTRIES[i][1];
          countrySelect.appendChild(opt);
        }

        countrySelect.value = (state.country || "GB").toUpperCase();
        countrySelect.addEventListener("change", function (e) {
          state.country = String(e.target.value || "GB").toUpperCase();
          saveState();
          // Refresh Radar immediately, and update provider info next time details are opened
          if (state.activeTab === "radar") {
            loadRadarUpcoming();
          } else {
            render();
          }
        });

        countryRow.appendChild(countrySelect);
        panel.appendChild(countryHeading);
        panel.appendChild(countryCopy);
        panel.appendChild(countryRow);

        panel.appendChild(sub);
        panel.appendChild(grid);


        const filterHeading = document.createElement("div");
        filterHeading.className = "settings-subheading";
        filterHeading.style.marginTop = "14px";
        filterHeading.textContent = "Discovery filters";

        const filterCopy = document.createElement("p");
        filterCopy.className = "settings-copy";
        filterCopy.textContent = "These filters affect Discover, For You and Radar.";

        const filterRow = document.createElement("div");
        filterRow.style.display = "flex";
        filterRow.style.flexWrap = "wrap";
        filterRow.style.gap = "10px";
        filterRow.style.alignItems = "center";

        // Min year
        const minYearWrap = document.createElement("label");
        minYearWrap.className = "controls-label";
        minYearWrap.style.display = "flex";
        minYearWrap.style.alignItems = "center";
        minYearWrap.style.gap = "6px";
        const minYearText = document.createElement("span");
        minYearText.textContent = "Minimum year";
        const minYearSelect = document.createElement("select");
        minYearSelect.className = "controls-select";
        minYearSelect.style.borderRadius = "14px";
        minYearSelect.style.padding = "6px 10px";

        const yearOptions = [0, 1950, 1960, 1970, 1980, 1990, 2000, 2010, 2020, new Date().getFullYear() - 1, new Date().getFullYear()];
        // De-dupe and sort
        const seenYears = {};
        const years = [];
        for (let i = 0; i < yearOptions.length; i++) {
          const y = yearOptions[i];
          if (seenYears[y]) continue;
          seenYears[y] = true;
          years.push(y);
        }
        years.sort(function(a,b){ return a-b; });

        for (let i = 0; i < years.length; i++) {
          const y = years[i];
          const opt = document.createElement("option");
          opt.value = String(y);
          opt.textContent = y === 0 ? "Any" : String(y);
          minYearSelect.appendChild(opt);
        }
        minYearSelect.value = String(state.filters && typeof state.filters.minYear === "number" ? state.filters.minYear : 0);
        minYearSelect.addEventListener("change", function (e) {
          const val = parseInt(e.target.value, 10);
          state.filters.minYear = isNaN(val) ? 0 : val;
          saveState();
          // Refresh current feed
          if (state.activeTab === "for-you") loadForYouRecommendations();
          else if (state.activeTab === "discover") loadPopularForDiscover();
          else if (state.activeTab === "radar") loadRadarUpcoming();
          else render();
        });

        minYearWrap.appendChild(minYearText);
        minYearWrap.appendChild(minYearSelect);

// TV series toggle
const tvBtn = document.createElement("button");
tvBtn.type = "button";
tvBtn.className = "pill-btn";
tvBtn.textContent = state.includeTv ? "TV series: Shown" : "TV series: Hidden";
tvBtn.addEventListener("click", function () {
  state.includeTv = !state.includeTv;
  tvBtn.textContent = state.includeTv ? "TV series: Shown" : "TV series: Hidden";
  saveState();
  if (state.activeTab === "for-you") loadForYouRecommendations();
  else if (state.activeTab === "discover") loadPopularForDiscover();
  else if (state.activeTab === "radar") loadRadarUpcoming();
  else render();
});


        // Hide watched
        const hideWatchedBtn = document.createElement("button");
        hideWatchedBtn.type = "button";
        hideWatchedBtn.className = "pill-btn";
        hideWatchedBtn.textContent = (state.filters && state.filters.hideWatched) ? "Hide watched: On" : "Hide watched: Off";
        hideWatchedBtn.addEventListener("click", function () {
          state.filters.hideWatched = !state.filters.hideWatched;
          hideWatchedBtn.textContent = state.filters.hideWatched ? "Hide watched: On" : "Hide watched: Off";
          saveState();
          render();
        });

        // Hide watchlist
        const hideWatchlistBtn = document.createElement("button");
        hideWatchlistBtn.type = "button";
        hideWatchlistBtn.className = "pill-btn";
        hideWatchlistBtn.textContent = (state.filters && state.filters.hideWatchlist) ? "Hide watchlist: On" : "Hide watchlist: Off";
        hideWatchlistBtn.addEventListener("click", function () {
          state.filters.hideWatchlist = !state.filters.hideWatchlist;
          hideWatchlistBtn.textContent = state.filters.hideWatchlist ? "Hide watchlist: On" : "Hide watchlist: Off";
          saveState();
          render();
        });

        filterRow.appendChild(minYearWrap);
        filterRow.appendChild(tvBtn);
        filterRow.appendChild(hideWatchedBtn);
        filterRow.appendChild(hideWatchlistBtn);

        const excludeSub = document.createElement("div");
        excludeSub.className = "settings-subheading";
        excludeSub.style.marginTop = "12px";
        excludeSub.textContent = "Exclude genres";

        const excludeCopy = document.createElement("p");
        excludeCopy.className = "settings-copy";
        excludeCopy.textContent = "These genres will be hidden from recommendations and discovery.";

        const excludeGrid = document.createElement("div");
        excludeGrid.className = "genre-grid";

        const excluded = {};
        const exArr = state.filters && Array.isArray(state.filters.excludedGenres) ? state.filters.excludedGenres : [];
        for (let i = 0; i < exArr.length; i++) excluded[exArr[i]] = true;

        function toggleExcludedGenre(id) {
          const arr = state.filters.excludedGenres;
          const idx = arr.indexOf(id);
          if (idx === -1) arr.push(id);
          else arr.splice(idx, 1);
          saveState();
          renderSettings();
        }

        for (let i = 0; i < GENRES.length; i++) {
          const genre = GENRES[i];
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "genre-pill";
          if (excluded[genre.id]) btn.classList.add("active");
          btn.textContent = genre.name;
          btn.addEventListener("click", function () {
            toggleExcludedGenre(genre.id);
          });
          excludeGrid.appendChild(btn);
        }

        panel.appendChild(filterHeading);
        panel.appendChild(filterCopy);
        panel.appendChild(filterRow);
        panel.appendChild(excludeSub);
        panel.appendChild(excludeCopy);
        panel.appendChild(excludeGrid);

        const toolsHeading = document.createElement("div");
        toolsHeading.className = "settings-subheading";
        toolsHeading.style.marginTop = "14px";
        toolsHeading.textContent = "Backup & restore";

        const toolsCopy = document.createElement("p");
        toolsCopy.className = "settings-copy";
        toolsCopy.textContent = "Export your watchlist, watched list and preferences to a file, or import them later.";

        const toolsRow = document.createElement("div");
        toolsRow.style.display = "flex";
        toolsRow.style.flexWrap = "wrap";
        toolsRow.style.gap = "8px";

        const exportBtn = document.createElement("button");
        exportBtn.type = "button";
        exportBtn.className = "pill-btn";
        exportBtn.textContent = "Export data";
        exportBtn.addEventListener("click", exportDataToFile);

        const importBtn = document.createElement("button");
        importBtn.type = "button";
        importBtn.className = "pill-btn";
        importBtn.textContent = "Import data";
        importBtn.addEventListener("click", function () {
          // iOS can block clicks on file inputs if they are display:none.
          // Create a temporary input inside the user gesture for maximum compatibility.
          const temp = document.createElement("input");
          temp.type = "file";
          temp.accept = "application/json";
          temp.style.position = "fixed";
          temp.style.left = "-9999px";
          temp.style.top = "-9999px";
          temp.style.width = "1px";
          temp.style.height = "1px";
          temp.style.opacity = "0";
          document.body.appendChild(temp);

          temp.addEventListener("change", function (e) {
            const files = temp.files;
            if (files && files[0]) {
              handleImportFile(files[0]);
            }
            document.body.removeChild(temp);
          });

          temp.click();
        });

        toolsRow.appendChild(exportBtn);
        toolsRow.appendChild(importBtn);

        panel.appendChild(toolsHeading);
        panel.appendChild(toolsCopy);
        panel.appendChild(toolsRow);
      }


      function getListById(listId) {
        for (let i = 0; i < state.lists.length; i++) {
          if (state.lists[i].id === listId) return state.lists[i];
        }
        return null;
      }
function listFilmCount(list) {
  if (!list) return 0;
  if (list.type === "smart") {
    return Array.isArray(list.cachedResults) ? list.cachedResults.length : 0;
  }
  return Array.isArray(list.entries) ? list.entries.length : 0;
}

function getListCoverPosterPaths(list) {
  const posters = [];
  function pushPoster(p) {
    if (!p) return;
    if (posters.indexOf(p) !== -1) return;
    posters.push(p);
  }

  if (list && list.type === "smart" && Array.isArray(list.cachedResults)) {
    for (let i = 0; i < list.cachedResults.length && posters.length < 4; i++) {
      pushPoster(list.cachedResults[i].poster_path || null);
    }
  } else if (list && Array.isArray(list.entries)) {
    for (let i = 0; i < list.entries.length && posters.length < 4; i++) {
      pushPoster(list.entries[i].posterPath || null);
    }
  }

  while (posters.length < 4) posters.push(null);
  return posters;
}

function togglePinList(listId) {
  const list = getListById(listId);
  if (!list) return;
  list.pinned = !list.pinned;
  saveState();
  render();
}


function toggleListsIndexReorderMode() {
  const ui = state.listsUi || { mode: "index", activeListId: null, reorderMode: false };
  if (ui.mode !== "index") return;
  ui.reorderMode = !ui.reorderMode;
  state.listsUi = ui;
  saveState();
  render();
}

function rebuildListsOrderFromPanel(panel) {
  if (!panel) return;
  const rows = panel.querySelectorAll(".list-row[data-list-id]");
  const pinnedIds = [];
  const unpinnedIds = [];
  for (let i = 0; i < rows.length; i++) {
    const id = rows[i].dataset.listId;
    const l = getListById(id);
    if (!l) continue;
    if (l.pinned) pinnedIds.push(id);
    else unpinnedIds.push(id);
  }

  const byId = {};
  for (let i = 0; i < state.lists.length; i++) byId[state.lists[i].id] = state.lists[i];

  const next = [];
  for (let i = 0; i < pinnedIds.length; i++) {
    const l = byId[pinnedIds[i]];
    if (l) {
      next.push(l);
      delete byId[pinnedIds[i]];
    }
  }
  for (let i = 0; i < unpinnedIds.length; i++) {
    const l = byId[unpinnedIds[i]];
    if (l) {
      next.push(l);
      delete byId[unpinnedIds[i]];
    }
  }
  // Any leftovers (shouldn't happen) are appended.
  for (const k in byId) next.push(byId[k]);

  state.lists = next;
}

function attachListsIndexDragHandlers(panel) {
  if (!panel) return;
  const handles = panel.querySelectorAll(".list-drag-handle");
  if (!handles || !handles.length) return;

  let draggingRow = null;
  let pointerId = null;

  function onMove(e) {
    if (!draggingRow) return;
    const el = document.elementFromPoint(e.clientX, e.clientY);
    const target = el ? el.closest(".list-row.reorderable") : null;
    if (!target || target === draggingRow) return;

    const dragId = draggingRow.dataset.listId;
    const targetId = target.dataset.listId;
    const a = getListById(dragId);
    const b = getListById(targetId);
    if (!a || !b) return;

    // Don't drag between pinned/unpinned groups (they'll just snap back).
    if (!!a.pinned !== !!b.pinned) return;

    const rect = target.getBoundingClientRect();
    const before = e.clientY < rect.top + rect.height / 2;
    if (before) {
      target.parentNode.insertBefore(draggingRow, target);
    } else {
      target.parentNode.insertBefore(draggingRow, target.nextSibling);
    }
  }

  function endDrag() {
    if (!draggingRow) return;
    draggingRow.classList.remove("dragging");
    try { draggingRow.releasePointerCapture(pointerId); } catch (_) {}
    draggingRow = null;
    pointerId = null;
    rebuildListsOrderFromPanel(panel);
    saveState();
    render();
  }

  for (let i = 0; i < handles.length; i++) {
    const h = handles[i];
    h.addEventListener("pointerdown", function (e) {
      if (e.button !== undefined && e.button !== 0) return;
      const row = h.closest(".list-row.reorderable");
      if (!row) return;
      draggingRow = row;
      pointerId = e.pointerId;
      row.classList.add("dragging");
      try { row.setPointerCapture(pointerId); } catch (_) {}
      e.preventDefault();
    });

    h.addEventListener("pointermove", function (e) {
      if (!draggingRow) return;
      if (e.pointerId !== pointerId) return;
      onMove(e);
    });

    h.addEventListener("pointerup", function (e) {
      if (e.pointerId !== pointerId) return;
      endDrag();
    });

    h.addEventListener("pointercancel", function (e) {
      if (e.pointerId !== pointerId) return;
      endDrag();
    });
  }
}

function renderMenuPinnedLists() {
  const section = document.getElementById("menu-pinned-section");
  const container = document.getElementById("menu-pinned-items");
  if (!section || !container) return;
  container.innerHTML = "";
  const pinned = state.lists.filter((l) => !!l.pinned);
  if (!pinned.length) {
    section.style.display = "none";
    return;
  }
  section.style.display = "block";
  // Preserve current list order
  const idxById = {};
  for (let i = 0; i < state.lists.length; i++) idxById[state.lists[i].id] = i;
  pinned.sort((a, b) => (idxById[a.id] ?? 0) - (idxById[b.id] ?? 0));

  for (let i = 0; i < pinned.length; i++) {
    const l = pinned[i];
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "menu-pinned-item";
    const left = document.createElement("div");
    left.className = "name";
    left.textContent = l.name || "Untitled list";
    const chev = document.createElement("div");
    chev.className = "chev";
    chev.textContent = "‚Ä∫";
    btn.appendChild(left);
    btn.appendChild(chev);
    btn.addEventListener("click", function () {
      closeMenu();
      openList(l.id);
    });
    container.appendChild(btn);
  }
}

function editListDescription(listId) {
  const list = getListById(listId);
  if (!list) return;
  const next = window.prompt("Edit description", list.description || "");
  if (next === null) return;
  list.description = String(next || "").trim();
  saveState();
  render();
}

function setListSortMode(listId, mode) {
  const list = getListById(listId);
  if (!list || list.type !== "manual") return;
  list.sortMode = mode;
  if (mode === "custom" && (!Array.isArray(list.customOrder) || !list.customOrder.length)) {
    // initialise custom order from current entries
    list.customOrder = [];
    for (let i = 0; i < list.entries.length; i++) {
      list.customOrder.push(list.entries[i].tmdbId);
    }
  }
  saveState();
  render();
}

function ensureCustomOrder(list) {
  if (!list || list.type !== "manual") return;
  if (!Array.isArray(list.customOrder)) list.customOrder = [];

  // Upgrade legacy numeric IDs to entry keys (movie)
  for (let i = 0; i < list.customOrder.length; i++) {
    if (typeof list.customOrder[i] === "number") {
      list.customOrder[i] = entryKey("movie", list.customOrder[i]);
    }
  }

  const present = {};
  for (let i = 0; i < list.customOrder.length; i++) present[list.customOrder[i]] = true;

  for (let i = 0; i < list.entries.length; i++) {
    const e = list.entries[i];
    const key = entryKey(e.mediaType || "movie", e.tmdbId);
    if (!present[key]) list.customOrder.push(key);
  }

  const next = [];
  for (let i = 0; i < list.customOrder.length; i++) {
    const key = list.customOrder[i];
    const p = parseEntryKey(key);
    let exists = false;
    for (let j = 0; j < list.entries.length; j++) {
      const e = list.entries[j];
      if (e.tmdbId === p.tmdbId && normaliseMediaType(e.mediaType || "movie") === p.mediaType) { exists = true; break; }
    }
    if (exists) next.push(key);
  }
  list.customOrder = next;
}

// Smart lists v2 (rule-based): supports country/year ranges, watched filter, genre include + exclude, and movies/TV/both.
function normaliseCountryCode(v, fallback) {
  const s = String(v || "").trim().toUpperCase();
  if (/^[A-Z]{2}$/.test(s)) return s;
  const fb = String(fallback || "").trim().toUpperCase();
  return /^[A-Z]{2}$/.test(fb) ? fb : "GB";
}

function splitCsv(str) {
  if (!str) return [];
  const parts = String(str).split(",");
  const out = [];
  for (let i = 0; i < parts.length; i++) {
    const p = String(parts[i] || "").trim();
    if (p) out.push(p);
  }
  return out;
}

function canonicalGenreName(name) {
  const want = String(name || "").trim().toLowerCase();
  if (!want) return null;
  for (let i = 0; i < GENRES.length; i++) {
    if (String(GENRES[i].name).toLowerCase() === want) return GENRES[i].name;
  }
  return null;
}

function genreNamesFromInput(input) {
  const parts = Array.isArray(input) ? input : splitCsv(input);
  const out = [];
  const seen = {};
  for (let i = 0; i < parts.length; i++) {
    const p = parts[i];
    // allow numeric IDs too (string numbers) ‚Äì we keep them as numbers in a separate list if needed
    const canon = canonicalGenreName(p);
    if (canon && !seen[canon]) {
      seen[canon] = true;
      out.push(canon);
    }
  }
  return out;
}

function movieGenreIdsFromNames(names) {
  const arr = Array.isArray(names) ? names : [];
  const out = [];
  const seen = {};
  for (let i = 0; i < arr.length; i++) {
    const canon = canonicalGenreName(arr[i]);
    if (!canon) continue;
    for (let j = 0; j < GENRES.length; j++) {
      if (GENRES[j].name === canon) {
        const id = GENRES[j].id;
        if (!seen[id]) { seen[id] = true; out.push(id); }
      }
    }
  }
  return out;
}

function tvGenreIdsFromNames(names) {
  const arr = Array.isArray(names) ? names : [];
  const out = [];
  const seen = {};
  for (let i = 0; i < arr.length; i++) {
    const canon = canonicalGenreName(arr[i]);
    if (!canon) continue;
    const id = TV_GENRE_IDS_BY_NAME[canon];
    if (typeof id === "number" && !seen[id]) { seen[id] = true; out.push(id); }
  }
  return out;
}

function watchedFilterFromInput(s) {
  const v = String(s || "").trim().toLowerCase();
  if (v === "watched" || v === "true" || v === "yes" || v === "y" || v === "1") return true;
  if (v === "unwatched" || v === "not watched" || v === "false" || v === "no" || v === "n" || v === "0") return false;
  return null;
}

function normaliseSmartMediaType(v) {
  const s = String(v || "").trim().toLowerCase();
  if (s === "tv" || s === "shows" || s === "show") return "tv";
  if (s === "both" || s === "all" || s === "movie+tv" || s === "movies+tv") return "both";
  return "movie";
}

function smartRulesSummary(rules) {
  if (!rules || typeof rules !== "object") return "";
  if (rules.v !== 2) return "";
  const bits = [];
  if (rules.country) bits.push("Country " + String(rules.country).toUpperCase());
  const y1 = (typeof rules.yearMin === "number" && rules.yearMin) ? rules.yearMin : 0;
  const y2 = (typeof rules.yearMax === "number" && rules.yearMax) ? rules.yearMax : 0;
  if (y1 && y2) bits.push(String(y1) + "‚Äì" + String(y2));
  else if (y1) bits.push("From " + String(y1));
  else if (y2) bits.push("Up to " + String(y2));
  if (rules.watched === true) bits.push("Watched only");
  if (rules.watched === false) bits.push("Unwatched only");
  const inc = Array.isArray(rules.includeGenreNames) ? rules.includeGenreNames : [];
  const exc = Array.isArray(rules.excludeGenreNames) ? rules.excludeGenreNames : [];
  if (inc.length) bits.push("+" + inc.join("/"));
  if (exc.length) bits.push("‚àí" + exc.join("/"));
  if (rules.mediaType) bits.push((rules.mediaType === "tv" ? "TV" : (rules.mediaType === "both" ? "Movies+TV" : "Movies")));
  return bits.join(" ‚Ä¢ ");
}

function buildSmartRulesV2ViaPrompts(existingRules) {
  const base = (existingRules && typeof existingRules === "object" && existingRules.v === 2) ? existingRules : {};

  const mtDefault = base.mediaType || (state.includeTv ? "both" : "movie");
  const mtIn = window.prompt("Media type for this smart list: movie / tv / both", mtDefault);
  if (mtIn === null) return null;
  const mediaType = normaliseSmartMediaType(mtIn);

  const cDefault = normaliseCountryCode(base.country, state.country || "GB");
  const cIn = window.prompt("Country / region code (2 letters). Example: JP, GB, US", cDefault);
  if (cIn === null) return null;
  const country = normaliseCountryCode(cIn, cDefault);

  const yMinIn = window.prompt("From year (e.g. 1980). Leave blank for any.", base.yearMin ? String(base.yearMin) : "");
  if (yMinIn === null) return null;
  const yMaxIn = window.prompt("To year (e.g. 1989). Leave blank for any.", base.yearMax ? String(base.yearMax) : "");
  if (yMaxIn === null) return null;

  const yearMin = yMinIn ? (parseInt(String(yMinIn).trim(), 10) || 0) : 0;
  const yearMax = yMaxIn ? (parseInt(String(yMaxIn).trim(), 10) || 0) : 0;

  const wDefault = (base.watched === true) ? "watched" : (base.watched === false ? "unwatched" : "any");
  const wIn = window.prompt("Watched filter: any / watched / unwatched", wDefault);
  if (wIn === null) return null;
  const watched = watchedFilterFromInput(wIn);

  const incDefault = Array.isArray(base.includeGenreNames) ? base.includeGenreNames.join(", ") : "";
  const incIn = window.prompt("Genres to include (comma-separated names). Example: Horror, Thriller. Leave blank for any.", incDefault);
  if (incIn === null) return null;
  const includeGenreNames = genreNamesFromInput(incIn);

  const excDefault = Array.isArray(base.excludeGenreNames) ? base.excludeGenreNames.join(", ") : "";
  const excIn = window.prompt("Genres to exclude (comma-separated names). Example: Comedy. Leave blank for none.", excDefault);
  if (excIn === null) return null;
  const excludeGenreNames = genreNamesFromInput(excIn);

  const sortDefault = typeof base.sortBy === "string" ? base.sortBy : "popularity.desc";
  const sortIn = window.prompt("Sort: popularity.desc / vote_average.desc / primary_release_date.desc / first_air_date.desc", sortDefault);
  if (sortIn === null) return null;
  const sortBy = String(sortIn || "popularity.desc").trim() || "popularity.desc";

  const minVoteDefault = (typeof base.minVote === "number") ? String(base.minVote) : "";
  const minVoteIn = window.prompt("Minimum rating (0‚Äì10). Leave blank for none.", minVoteDefault);
  if (minVoteIn === null) return null;
  const minVote = minVoteIn ? (parseFloat(String(minVoteIn).trim()) || 0) : 0;

  return {
    v: 2,
    mediaType: mediaType,
    country: country,
    yearMin: yearMin,
    yearMax: yearMax,
    watched: watched,
    includeGenreNames: includeGenreNames,
    excludeGenreNames: excludeGenreNames,
    sortBy: sortBy,
    minVote: minVote
  };
}

function editSmartListRules(listId) {
  const list = getListById(listId);
  if (!list || list.type !== "smart") return;

  // Upgrade legacy v1 rules into v2 defaults (best-effort)
  let current = list.smartRules;
  if (current && typeof current === "object" && current.v !== 2) {
    const incNames = [];
    if (Array.isArray(current.withGenres)) {
      for (let i = 0; i < current.withGenres.length; i++) {
        const id = current.withGenres[i];
        for (let j = 0; j < GENRES.length; j++) {
          if (GENRES[j].id === id) incNames.push(GENRES[j].name);
        }
      }
    }
    current = {
      v: 2,
      mediaType: "movie",
      country: state.country || "GB",
      yearMin: typeof current.yearMin === "number" ? current.yearMin : 0,
      yearMax: typeof current.yearMax === "number" ? current.yearMax : 0,
      watched: null,
      includeGenreNames: incNames,
      excludeGenreNames: [],
      sortBy: typeof current.sortBy === "string" ? current.sortBy : "popularity.desc",
      minVote: typeof current.minVote === "number" ? current.minVote : 0
    };
  }

  const next = buildSmartRulesV2ViaPrompts(current || null);
  if (!next) return;
  list.smartRules = next;
  saveState();
  refreshSmartList(list.id);
}

async function fetchSmartListResults(list) {
  if (!list || list.type !== "smart" || !list.smartRules) return;

  const rules = list.smartRules;

  // v2: rule-based smart lists (movies/TV/both + include/exclude + watched filter)
  if (rules && typeof rules === "object" && rules.v === 2) {
    const country = normaliseCountryCode(rules.country, state.country || "GB");
    const yearMin = typeof rules.yearMin === "number" ? rules.yearMin : 0;
    const yearMax = typeof rules.yearMax === "number" ? rules.yearMax : 0;
    const sortBy = typeof rules.sortBy === "string" ? rules.sortBy : "popularity.desc";
    const minVote = typeof rules.minVote === "number" ? rules.minVote : 0;
    const mediaType = normaliseSmartMediaType(rules.mediaType);

    const includeNames = Array.isArray(rules.includeGenreNames) ? rules.includeGenreNames : [];
    const excludeNames = Array.isArray(rules.excludeGenreNames) ? rules.excludeGenreNames : [];
    const watchedFilter = (rules.watched === true || rules.watched === false) ? rules.watched : null;

    async function discover(mt) {
      const endpoint = mt === "tv" ? "tv" : "movie";
      const url = new URL("https://api.themoviedb.org/3/discover/" + endpoint);
      url.searchParams.set("api_key", TMDB_API_KEY);
      url.searchParams.set("language", "en-GB");
      url.searchParams.set("page", "1");
      // Country: best-effort. For movies, region affects release dates; for TV, TMDB varies by endpoint.
      url.searchParams.set("region", country);
      url.searchParams.set("watch_region", country);
      url.searchParams.set("with_origin_country", country);

      if (minVote) url.searchParams.set("vote_average.gte", String(minVote));
      url.searchParams.set("sort_by", sortBy);

      if (mt === "movie") {
        if (yearMin) url.searchParams.set("primary_release_date.gte", String(yearMin) + "-01-01");
        if (yearMax) url.searchParams.set("primary_release_date.lte", String(yearMax) + "-12-31");
        const incIds = movieGenreIdsFromNames(includeNames);
        const excIds = movieGenreIdsFromNames(excludeNames);
        if (incIds.length) url.searchParams.set("with_genres", incIds.join(","));
        if (excIds.length) url.searchParams.set("without_genres", excIds.join(","));
      } else {
        if (yearMin) url.searchParams.set("first_air_date.gte", String(yearMin) + "-01-01");
        if (yearMax) url.searchParams.set("first_air_date.lte", String(yearMax) + "-12-31");
        const incIds = tvGenreIdsFromNames(includeNames);
        const excIds = tvGenreIdsFromNames(excludeNames);
        if (incIds.length) url.searchParams.set("with_genres", incIds.join(","));
        if (excIds.length) url.searchParams.set("without_genres", excIds.join(","));
      }

      const data = await tmdbFetch(url);
      const results = Array.isArray(data.results) ? data.results : [];
      for (let i = 0; i < results.length; i++) results[i].media_type = mt;
      return results;
    }

    let merged = [];
    if (mediaType === "both") {
      const both = await Promise.all([discover("movie"), discover("tv")]);
      merged = (both[0] || []).concat(both[1] || []);
      // Consistent ordering for mixed media lists
      merged.sort(function (a, b) { return (b.popularity || 0) - (a.popularity || 0); });
    } else {
      merged = await discover(mediaType);
    }

    if (watchedFilter !== null) {
      const filtered = [];
      for (let i = 0; i < merged.length; i++) {
        const obj = merged[i];
        const linked = linkSavedItemFromTmdb(obj, inferMediaTypeFromTmdb(obj, "movie"));
        const isWatched = linked ? !!linked.watched : false;
        if (watchedFilter === true) {
          if (isWatched) filtered.push(obj);
        } else {
          if (!isWatched) filtered.push(obj);
        }
      }
      merged = filtered;
    }

    if (state.mood && state.mood !== "any") {
      const mf = [];
      for (let i = 0; i < merged.length; i++) {
        if (moodMatchesTmdb(merged[i])) mf.push(merged[i]);
      }
      merged = mf;
    }

    list.cachedResults = merged.slice(0, 80);
    list.cachedAt = Date.now();
    saveState();
    return;
  }

  // Legacy v1 smart lists (movie-only)
  const url = new URL("https://api.themoviedb.org/3/discover/movie");
  url.searchParams.set("api_key", TMDB_API_KEY);
  url.searchParams.set("language", "en-GB");
  url.searchParams.set("region", (state.country || "GB"));
  url.searchParams.set("page", "1");

  const withGenres = Array.isArray(rules.withGenres) ? rules.withGenres : [];
  const yearMin = typeof rules.yearMin === "number" ? rules.yearMin : 0;
  const yearMax = typeof rules.yearMax === "number" ? rules.yearMax : 0;
  const sortBy = typeof rules.sortBy === "string" ? rules.sortBy : "popularity.desc";
  const minVote = typeof rules.minVote === "number" ? rules.minVote : 0;

  if (withGenres.length) url.searchParams.set("with_genres", withGenres.join(","));
  if (yearMin) url.searchParams.set("primary_release_date.gte", String(yearMin) + "-01-01");
  if (yearMax) url.searchParams.set("primary_release_date.lte", String(yearMax) + "-12-31");
  if (minVote) url.searchParams.set("vote_average.gte", String(minVote));
  url.searchParams.set("sort_by", sortBy);

  const data = await tmdbFetch(url);
  list.cachedResults = Array.isArray(data.results) ? data.results : [];
  list.cachedAt = Date.now();
  saveState();
}

async function refreshSmartList(listId) {
  const list = getListById(listId);
  if (!list || list.type !== "smart") return;
  els.message.style.display = "block";
  els.message.textContent = "Refreshing list‚Ä¶";
  try {
    await fetchSmartListResults(list);
  } catch (e) {
    console.error(e);
    alertNice("Sorry ‚Äî we couldn‚Äôt refresh this list.");
  } finally {
    render();
  }
}

function createSmartListPreset() {
  const name = window.prompt("Smart list name", "Horror 80s");
  if (name === null) return;
  const clean = String(name || "").trim();
  if (!clean) {
    alertNice("Please enter a list name.");
    return;
  }

  const choice = window.prompt(
    "Choose a preset:\n1) Horror 80s (unwatched)\n2) Top rated (your favourite genres, unwatched)\n3) Custom rules (v2)",
    "1"
  );
  if (choice === null) return;

  let rules = null;
  const c = String(choice).trim();

  if (c === "1") {
    rules = {
      v: 2,
      mediaType: "movie",
      country: state.country || "GB",
      yearMin: 1980,
      yearMax: 1989,
      watched: false,
      includeGenreNames: ["Horror"],
      excludeGenreNames: [],
      sortBy: "popularity.desc",
      minVote: 0
    };
  } else if (c === "2") {
    const fav = Array.isArray(state.favouriteGenres) ? state.favouriteGenres : [];
    const names = [];
    for (let i = 0; i < fav.length; i++) {
      const id = fav[i];
      for (let j = 0; j < GENRES.length; j++) {
        if (GENRES[j].id === id) names.push(GENRES[j].name);
      }
    }
    rules = {
      v: 2,
      mediaType: state.includeTv ? "both" : "movie",
      country: state.country || "GB",
      yearMin: 0,
      yearMax: 0,
      watched: false,
      includeGenreNames: names,
      excludeGenreNames: [],
      sortBy: "vote_average.desc",
      minVote: 7
    };
  } else {
    rules = buildSmartRulesV2ViaPrompts({ v: 2, mediaType: (state.includeTv ? "both" : "movie"), country: state.country || "GB" });
    if (!rules) return;
  }

  const desc = window.prompt("Optional description", smartRulesSummary(rules));
  if (desc === null) return;

  const list = {
    id: safeId(),
    type: "smart",
    name: clean,
    description: String(desc || "").trim(),
    pinned: false,
    smartRules: rules,
    cachedResults: [],
    cachedAt: 0,
    entries: [],
    sortMode: "custom",
    customOrder: [],
    createdAt: Date.now()
  };

  state.lists.push(list);
  state.listsUi = { mode: "detail", activeListId: list.id, reorderMode: false };
  saveState();
  // Fetch immediately
  refreshSmartList(list.id);
}

function moveEntryInList(listId, entryKeyValue, direction) {
  const list = getListById(listId);
  if (!list || list.type !== "manual") return;
  ensureCustomOrder(list);

  const key = typeof entryKeyValue === "string"
    ? entryKeyValue
    : entryKey("movie", entryKeyValue);

  const idx = list.customOrder.indexOf(key);
  if (idx === -1) return;
  const nextIdx = idx + direction;
  if (nextIdx < 0 || nextIdx >= list.customOrder.length) return;
  const tmp = list.customOrder[idx];
  list.customOrder[idx] = list.customOrder[nextIdx];
  list.customOrder[nextIdx] = tmp;
  saveState();
  render();
}


      function createList(name, description) {
  const clean = (name || "").trim();
  if (!clean) {
    alertNice("Please enter a list name.");
    return;
  }
  const list = {
    id: safeId(),
    type: "manual",
    name: clean,
    description: (description || "").trim(),
    pinned: false,
    sortMode: "custom",
    customOrder: [],
    entries: [],
    createdAt: Date.now()
  };
  state.lists.push(list);
  state.listsUi = { mode: "detail", activeListId: list.id, reorderMode: false };
  saveState();
  render();
}

      function renameList(listId) {
        const list = getListById(listId);
        if (!list) return;
        const next = window.prompt("Rename list", list.name);
        if (next === null) return;
        const clean = next.trim();
        if (!clean) {
          alertNice("List name can‚Äôt be empty.");
          return;
        }
        list.name = clean;
        saveState();
        render();
      }

      function deleteList(listId) {
        const list = getListById(listId);
        if (!list) return;
        const ok = window.confirm("Delete ‚Äú" + list.name + "‚Äù? This can‚Äôt be undone.");
        if (!ok) return;

        const nextLists = [];
        for (let i = 0; i < state.lists.length; i++) {
          if (state.lists[i].id !== listId) nextLists.push(state.lists[i]);
        }
        state.lists = nextLists;
        state.listsUi = { mode: "index", activeListId: null, reorderMode: false };
        saveState();
        render();
      }

      function addTmdbToList(listId, detailsOrMovie, mediaType) {
  const list = getListById(listId);
  if (!list) return;

  const tmdbId = detailsOrMovie.id;
  const mt = normaliseMediaType(mediaType || detailsOrMovie.media_type || "movie");
  const key = entryKey(mt, tmdbId);

  if (list.type === "manual") {
    for (let i = 0; i < list.entries.length; i++) {
      const e = list.entries[i];
      if (e.tmdbId === tmdbId && normaliseMediaType(e.mediaType || "movie") === mt) return;
    }
  } else if (list.type === "smart") {
    alertNice("This is a smart list. You can‚Äôt add items manually.");
    return;
  }

  const title = titleFromTmdb(detailsOrMovie);
  const year = yearFromTmdb(detailsOrMovie);

  list.entries.push({
    tmdbId: tmdbId,
    mediaType: mt,
    title: title,
    year: year,
    posterPath: detailsOrMovie.poster_path || null,
    rating: typeof detailsOrMovie.vote_average === "number" ? detailsOrMovie.vote_average : null,
    addedAt: Date.now()
  });

  ensureCustomOrder(list);
  if (list.customOrder.indexOf(key) === -1) list.customOrder.push(key);

  saveState();
  render();
}

      function removeTmdbFromList(listId, tmdbId, mediaType) {
  const list = getListById(listId);
  if (!list || list.type !== "manual") return;

  const mt = normaliseMediaType(mediaType || "movie");

  const next = [];
  for (let i = 0; i < list.entries.length; i++) {
    const e = list.entries[i];
    if (e.tmdbId === tmdbId && normaliseMediaType(e.mediaType || "movie") === mt) continue;
    next.push(e);
  }
  list.entries = next;

  ensureCustomOrder(list);
  const key = entryKey(mt, tmdbId);
  const orderNext = [];
  for (let i = 0; i < list.customOrder.length; i++) {
    if (list.customOrder[i] !== key) orderNext.push(list.customOrder[i]);
  }
  list.customOrder = orderNext;

  saveState();
  render();
}

      function openList(listId) {
  state.listsUi = { mode: "detail", activeListId: listId, reorderMode: false };
  saveState();

  const list = getListById(listId);
  if (list && list.type === "smart") {
    const stale = !list.cachedAt || (Date.now() - list.cachedAt) > 24 * 60 * 60 * 1000;
    if (stale || !Array.isArray(list.cachedResults) || !list.cachedResults.length) {
      refreshSmartList(listId);
      return;
    }
  }
  render();
}

      function backToListsIndex() {
        state.listsUi = { mode: "index", activeListId: null, reorderMode: false };
        saveState();
        render();
      }

      
      // -------- Account (basic config + sign-in stub) --------
      // This prevents the Account tab rendering blank.
      // Data sync can be wired up later once auth + tables are ready.
      let rqSupabaseClient = null;
      let rqSupabaseClientKey = "";
      let rqSupabaseLoading = null;

      function getSupabaseConfig() {
        const url = String(localStorage.getItem("rq_supabase_url") || "").trim();
        const anon = String(localStorage.getItem("rq_supabase_anon") || "").trim();
        return { url, anon };
      }

      function setSupabaseConfig(url, anon) {
        localStorage.setItem("rq_supabase_url", String(url || "").trim());
        localStorage.setItem("rq_supabase_anon", String(anon || "").trim());
      }

      function loadSupabaseScriptOnce() {
        if (window.supabase && window.supabase.createClient) return Promise.resolve();
        if (rqSupabaseLoading) return rqSupabaseLoading;

        rqSupabaseLoading = new Promise(function (resolve, reject) {
          const s = document.createElement("script");
          s.src = "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2";
          s.async = true;
          s.onload = function () { resolve(); };
          s.onerror = function () { reject(new Error("Failed to load Supabase JS")); };
          document.head.appendChild(s);
        });

        return rqSupabaseLoading;
      }

      async function getSupabaseClient() {
        const cfg = getSupabaseConfig();
        if (!cfg.url || !cfg.anon) return null;

        const key = cfg.url + "::" + cfg.anon;
        if (rqSupabaseClient && rqSupabaseClientKey === key) return rqSupabaseClient;

        await loadSupabaseScriptOnce();
        if (!window.supabase || !window.supabase.createClient) return null;

        rqSupabaseClient = window.supabase.createClient(cfg.url, cfg.anon, {
          auth: { persistSession: true, autoRefreshToken: true, detectSessionInUrl: true }
        });
        rqSupabaseClientKey = key;
        return rqSupabaseClient;
      }

      function renderAccount() {
        const panel = els.accountPanel;
        if (!panel) return;

        panel.innerHTML = "";

        const heading = document.createElement("h2");
        heading.className = "settings-heading";
        heading.textContent = "Account";

        const copy = document.createElement("p");
        copy.className = "settings-copy";
        copy.textContent = "Sign in to sync your ReelQuest across devices. (Sync storage is a follow-up step ‚Äî this page now works.)";

        const cfg = getSupabaseConfig();

        const sub = document.createElement("div");
        sub.className = "settings-subheading";
        sub.textContent = "Supabase connection";

        const urlLabel = document.createElement("label");
        urlLabel.className = "settings-label";
        urlLabel.textContent = "Project URL";
        const urlInput = document.createElement("input");
        urlInput.className = "search-input";
        urlInput.placeholder = "https://xxxx.supabase.co";
        urlInput.value = cfg.url || "";
        urlLabel.appendChild(urlInput);

        const keyLabel = document.createElement("label");
        keyLabel.className = "settings-label";
        keyLabel.textContent = "Anon key";
        const keyInput = document.createElement("input");
        keyInput.className = "search-input";
        keyInput.type = "password";
        keyInput.placeholder = "Paste anon public key";
        keyInput.value = cfg.anon || "";
        keyLabel.appendChild(keyInput);

        const row = document.createElement("div");
        row.style.display = "flex";
        row.style.flexWrap = "wrap";
        row.style.gap = "10px";
        row.style.alignItems = "center";

        const saveBtn = document.createElement("button");
        saveBtn.type = "button";
        saveBtn.className = "pill-btn";
        saveBtn.textContent = "Save connection";
        saveBtn.addEventListener("click", function () {
          setSupabaseConfig(urlInput.value, keyInput.value);
          toast("Saved.");
          renderAccount();
        });

        const status = document.createElement("div");
        status.className = "settings-copy";
        status.style.marginTop = "10px";
        status.textContent = (!cfg.url || !cfg.anon)
          ? "Status: Not configured yet."
          : "Status: Checking sign-in‚Ä¶";

        const authSub = document.createElement("div");
        authSub.className = "settings-subheading";
        authSub.style.marginTop = "14px";
        authSub.textContent = "Sign in";

        const emailWrap = document.createElement("div");
        emailWrap.style.display = "flex";
        emailWrap.style.flexWrap = "wrap";
        emailWrap.style.gap = "10px";
        emailWrap.style.alignItems = "center";

        const emailInput = document.createElement("input");
        emailInput.className = "search-input";
        emailInput.placeholder = "Email address";
        emailInput.inputMode = "email";
        emailInput.autocomplete = "email";
        emailInput.style.flex = "1 1 240px";

        const linkBtn = document.createElement("button");
        linkBtn.type = "button";
        linkBtn.className = "pill-btn";
        linkBtn.textContent = "Send magic link";

        const signOutBtn = document.createElement("button");
        signOutBtn.type = "button";
        signOutBtn.className = "pill-btn";
        signOutBtn.textContent = "Sign out";
        signOutBtn.style.display = "none";

        saveBtn.style.marginRight = "6px";
        row.appendChild(saveBtn);

        emailWrap.appendChild(emailInput);
        emailWrap.appendChild(linkBtn);
        emailWrap.appendChild(signOutBtn);

        linkBtn.addEventListener("click", async function () {
          const cfg2 = getSupabaseConfig();
          if (!cfg2.url || !cfg2.anon) {
            alertNice("Add your Supabase Project URL + anon key first.");
            return;
          }
          const email = String(emailInput.value || "").trim();
          if (!email || email.indexOf("@") === -1) {
            alertNice("Enter a valid email address.");
            return;
          }
          try {
            const client = await getSupabaseClient();
            if (!client) throw new Error("Supabase client not available");
            await client.auth.signInWithOtp({
              email,
              options: { emailRedirectTo: (location.origin + location.pathname) }
            });
            toast("Magic link sent.");
          } catch (e) {
            console.error(e);
            alertNice("Couldn‚Äôt send the magic link. Check the URL/key and try again.");
          }
        });

        signOutBtn.addEventListener("click", async function () {
          try {
            const client = await getSupabaseClient();
            if (!client) return;
            await client.auth.signOut();
            toast("Signed out.");
            renderAccount();
          } catch (e) {
            console.error(e);
            alertNice("Couldn‚Äôt sign out.");
          }
        });

        panel.appendChild(heading);
        panel.appendChild(copy);
        panel.appendChild(sub);
        panel.appendChild(urlLabel);
        panel.appendChild(keyLabel);
        panel.appendChild(row);
        panel.appendChild(status);
        panel.appendChild(authSub);
        panel.appendChild(emailWrap);

        // Async: update sign-in status if configured
        if (cfg.url && cfg.anon) {
          (async function () {
            try {
              const client = await getSupabaseClient();
              if (!client) { status.textContent = "Status: Supabase client failed to load."; return; }

              const userRes = await client.auth.getUser();
              const user = userRes && userRes.data ? userRes.data.user : null;

              if (user && user.email) {
                status.textContent = "Status: Signed in as " + user.email;
                signOutBtn.style.display = "inline-flex";
              } else {
                status.textContent = "Status: Not signed in.";
                signOutBtn.style.display = "none";
              }
            } catch (e) {
              console.error(e);
              status.textContent = "Status: Couldn‚Äôt check sign-in (URL/key may be wrong).";
            }
          })();
        }
      }

function renderListsPanel() {
  const panel = els.listsPanel;
  panel.innerHTML = "";

  const heading = document.createElement("h2");
  heading.className = "settings-heading";
  heading.textContent = "Lists";

  const copy = document.createElement("p");
  copy.className = "settings-copy";
  copy.textContent = "Create and curate your own collections (manual lists), or use smart lists that auto-fill from TMDB.";

  panel.appendChild(heading);
  panel.appendChild(copy);

  const ui = state.listsUi || { mode: "index", activeListId: null, reorderMode: false };

  if (ui.mode === "index") {
    const tools = document.createElement("div");
    tools.style.display = "flex";
    tools.style.flexWrap = "wrap";
    tools.style.gap = "8px";
    tools.style.marginTop = "10px";

    const createManualBtn = document.createElement("button");
    createManualBtn.type = "button";
    createManualBtn.className = "pill-btn";
    createManualBtn.textContent = "Create manual list";
    createManualBtn.addEventListener("click", function () {
      const name = window.prompt("List name", "My favourite horror films");
      if (name === null) return;
      const desc = window.prompt("Optional description", "");
      if (desc === null) return;
      createList(name, desc);
    });

    const createSmartBtn = document.createElement("button");
    createSmartBtn.type = "button";
    createSmartBtn.className = "pill-btn";
    createSmartBtn.textContent = "Create smart list";
    createSmartBtn.addEventListener("click", function () {
      createSmartListPreset();
    });

    tools.appendChild(createManualBtn);
    tools.appendChild(createSmartBtn);

    const importListBtn = document.createElement("button");
    importListBtn.type = "button";
    importListBtn.className = "pill-btn";
    importListBtn.textContent = "Import list";
    importListBtn.addEventListener("click", function () {
      pickAndImportSingleList();
    });

    tools.appendChild(importListBtn);

    const reorderBtn = document.createElement("button");
    reorderBtn.type = "button";
    reorderBtn.className = "pill-btn";
    reorderBtn.textContent = ui.reorderMode ? "Done reordering" : "Reorder lists";
    reorderBtn.addEventListener("click", function () {
      toggleListsIndexReorderMode();
    });
    tools.appendChild(reorderBtn);

    panel.appendChild(tools);

    const listHeading = document.createElement("div");
    listHeading.className = "settings-subheading";
    listHeading.style.marginTop = "14px";
    listHeading.textContent = "Your lists";
    panel.appendChild(listHeading);

    if (!state.lists.length) {
      const none = document.createElement("p");
      none.className = "settings-copy";
      none.textContent = "No lists yet. Create one above, then add films to it from a film‚Äôs details.";
      panel.appendChild(none);
      return;
    }

    // Pinned lists first, then your custom order
    const lists = state.lists.slice();
    const idxById = {};
    for (let i = 0; i < state.lists.length; i++) idxById[state.lists[i].id] = i;
    lists.sort(function (a, b) {
      const ap = a.pinned ? 1 : 0;
      const bp = b.pinned ? 1 : 0;
      if (ap !== bp) return bp - ap;
      return (idxById[a.id] ?? 0) - (idxById[b.id] ?? 0);
    });

    for (let i = 0; i < lists.length; i++) {
      const l = lists[i];

      const row = document.createElement("div");
      row.className = "list-row";

      const left = document.createElement("div");
      left.className = "list-left";

      if (ui.reorderMode) {
        row.classList.add("reorderable");
        row.dataset.listId = l.id;

        const handle = document.createElement("div");
        handle.className = "list-drag-handle";
        handle.textContent = "‚â°";
        handle.title = "Drag to reorder";
        handle.dataset.listId = l.id;
        left.appendChild(handle);
      }

      const cover = document.createElement("div");
      cover.className = "list-cover";
      const posters = getListCoverPosterPaths(l);
      for (let p = 0; p < posters.length; p++) {
        const img = document.createElement("img");
        if (posters[p]) {
          img.src = "https://image.tmdb.org/t/p/w92" + posters[p];
          img.alt = "";
        } else {
          img.alt = "";
          img.src =
            "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='92' height='92'%3E%3Crect width='92' height='92' fill='%232a2a2a'/%3E%3C/svg%3E";
        }
        cover.appendChild(img);
      }

      const text = document.createElement("div");
      text.className = "list-text";

      const name = document.createElement("div");
      name.className = "list-name";
      name.textContent = l.name;

      const desc = document.createElement("div");
      desc.className = "list-desc";
      desc.textContent = l.description ? l.description : (l.type === "smart" ? "Smart list" : "Manual list");

      const meta = document.createElement("div");
      meta.className = "list-meta";
      const count = listFilmCount(l);
      meta.textContent = count + " film" + (count === 1 ? "" : "s") + (l.type === "smart" ? " ‚Ä¢ auto-updating" : "");

      text.appendChild(name);
      text.appendChild(desc);
      text.appendChild(meta);

      left.appendChild(cover);
      left.appendChild(text);

      const actions = document.createElement("div");
      actions.className = "list-actions";

      const pinBtn = document.createElement("button");
      pinBtn.type = "button";
      pinBtn.className = "pill-btn pin-btn";
      pinBtn.title = l.pinned ? "Unpin list" : "Pin list";
      pinBtn.textContent = l.pinned ? "‚òÖ" : "‚òÜ";
      pinBtn.addEventListener("click", function () {
        togglePinList(l.id);
      });

      const openBtn = document.createElement("button");
      openBtn.type = "button";
      openBtn.className = "pill-btn";
      openBtn.textContent = "Open";
      openBtn.addEventListener("click", function () {
        openList(l.id);
      });

      const descBtn = document.createElement("button");
      descBtn.type = "button";
      descBtn.className = "pill-btn";
      descBtn.textContent = "Edit";
      descBtn.addEventListener("click", function () {
        editListDescription(l.id);
      });

      const deleteBtn = document.createElement("button");
      deleteBtn.type = "button";
      deleteBtn.className = "pill-btn";
      deleteBtn.textContent = "Delete";
      deleteBtn.addEventListener("click", function () {
        deleteList(l.id);
      });

      actions.appendChild(pinBtn);
      actions.appendChild(openBtn);
      actions.appendChild(descBtn);
      actions.appendChild(deleteBtn);

      row.appendChild(left);
      row.appendChild(actions);
      panel.appendChild(row);
    }

    if (ui.reorderMode) {
      attachListsIndexDragHandlers(panel);
    }

    return;
  }

  // Detail view
  const list = getListById(ui.activeListId);
  if (!list) {
    state.listsUi = { mode: "index", activeListId: null, reorderMode: false };
    saveState();
    render();
    return;
  }

  const topRow = document.createElement("div");
  topRow.style.display = "flex";
  topRow.style.alignItems = "center";
  topRow.style.justifyContent = "space-between";
  topRow.style.gap = "8px";
  topRow.style.marginTop = "10px";

  const backBtn = document.createElement("button");
  backBtn.type = "button";
  backBtn.className = "pill-btn";
  backBtn.textContent = "Back";
  backBtn.addEventListener("click", backToListsIndex);

  const right = document.createElement("div");
  right.style.display = "flex";
  right.style.gap = "6px";
  right.style.flexWrap = "wrap";

  const pinBtn = document.createElement("button");
  pinBtn.type = "button";
  pinBtn.className = "pill-btn";
  pinBtn.textContent = list.pinned ? "Unpin" : "Pin";
  pinBtn.addEventListener("click", function () {
    togglePinList(list.id);
  });

  const descBtn = document.createElement("button");
  descBtn.type = "button";
  descBtn.className = "pill-btn";
  descBtn.textContent = "Edit description";
  descBtn.addEventListener("click", function () {
    editListDescription(list.id);
  });

  if (list.type === "smart") {
    const refreshBtn = document.createElement("button");
    refreshBtn.type = "button";
    refreshBtn.className = "pill-btn";
    refreshBtn.textContent = "Refresh";
    refreshBtn.addEventListener("click", function () {
      refreshSmartList(list.id);
    });

    const rulesBtn = document.createElement("button");
    rulesBtn.type = "button";
    rulesBtn.className = "pill-btn";
    rulesBtn.textContent = "Edit rules";
    rulesBtn.addEventListener("click", function () {
      editSmartListRules(list.id);
    });

    right.appendChild(refreshBtn);
    right.appendChild(rulesBtn);
  } else {
    const sortSelect = document.createElement("select");
    sortSelect.className = "controls-select";
    sortSelect.style.borderRadius = "14px";
    sortSelect.style.padding = "6px 10px";

    const modes = [
      ["custom", "Custom order"],
      ["rating", "Rating (highest)"],
      ["year", "Year (newest)"],
      ["title", "Title (A‚ÄìZ)"]
    ];

    for (let i = 0; i < modes.length; i++) {
      const opt = document.createElement("option");
      opt.value = modes[i][0];
      opt.textContent = modes[i][1];
      sortSelect.appendChild(opt);
    }
    sortSelect.value = list.sortMode || "custom";
    sortSelect.addEventListener("change", function (e) {
      setListSortMode(list.id, e.target.value);
    });

    const reorderBtn = document.createElement("button");
    reorderBtn.type = "button";
    reorderBtn.className = "pill-btn";
    reorderBtn.textContent = ui.reorderMode ? "Done reordering" : "Reorder";
    reorderBtn.addEventListener("click", function () {
      state.listsUi.reorderMode = !state.listsUi.reorderMode;
      saveState();
      render();
    });

    right.appendChild(sortSelect);
    right.appendChild(reorderBtn);
  }

  const deleteBtn = document.createElement("button");
  deleteBtn.type = "button";
  deleteBtn.className = "pill-btn";
  deleteBtn.textContent = "Delete";
  deleteBtn.addEventListener("click", function () {
    deleteList(list.id);
  });

  right.appendChild(pinBtn);
  right.appendChild(descBtn);

const shareBtn = document.createElement("button");
shareBtn.type = "button";
shareBtn.className = "pill-btn";
shareBtn.textContent = "Share";
shareBtn.addEventListener("click", function () {
  shareList(list.id);
});

const exportListBtn = document.createElement("button");
exportListBtn.type = "button";
exportListBtn.className = "pill-btn";
exportListBtn.textContent = "Export";
exportListBtn.addEventListener("click", function () {
  exportSingleListToFile(list.id);
});

  right.appendChild(shareBtn);
  right.appendChild(exportListBtn);

  right.appendChild(deleteBtn);

  topRow.appendChild(backBtn);
  topRow.appendChild(right);

  const name = document.createElement("div");
  name.className = "settings-heading";
  name.style.marginTop = "12px";
  name.textContent = list.name;

  const meta = document.createElement("p");
  meta.className = "settings-copy";
  meta.textContent =
    (list.description ? (list.description + " ‚Ä¢ ") : "") +
    "Films in this list: " + listFilmCount(list) + ".";

  const hint = document.createElement("p");
  hint.className = "settings-copy";
  hint.textContent = list.type === "smart"
    ? "This list auto-updates from TMDB. Tap Refresh to fetch the latest."
    : "Tip: open any film‚Äôs details and use ‚ÄúAdd to list‚Äù.";

  panel.appendChild(topRow);
  panel.appendChild(name);
  panel.appendChild(meta);
  panel.appendChild(hint);

  if (list.type === "manual" && ui.reorderMode && (list.sortMode || "custom") === "custom") {
    ensureCustomOrder(list);

    const listBox = document.createElement("div");
    listBox.className = "reorder-list";

    // Build title lookup
    function titleFor(key) {
      const p = parseEntryKey(key);
      for (let i = 0; i < list.entries.length; i++) {
        const e = list.entries[i];
        const mt = normaliseMediaType(e.mediaType || "movie");
        if (e.tmdbId === p.tmdbId && mt === p.mediaType) return (e.title || "Untitled") + (p.mediaType === "tv" ? " (TV)" : "");
      }
      return "Untitled";
    }

    for (let i = 0; i < list.customOrder.length; i++) {
      const id = list.customOrder[i];
      const item = document.createElement("div");
      item.className = "reorder-item";

      const t = document.createElement("div");
      t.className = "reorder-title";
      t.textContent = titleFor(id);

      const controls = document.createElement("div");
      controls.className = "reorder-controls";

      const up = document.createElement("button");
      up.type = "button";
      up.className = "card-btn";
      up.title = "Move up";
      up.textContent = "‚Üë";
      up.disabled = i === 0;
      up.addEventListener("click", function () {
        moveEntryInList(list.id, id, -1);
      });

      const down = document.createElement("button");
      down.type = "button";
      down.className = "card-btn";
      down.title = "Move down";
      down.textContent = "‚Üì";
      down.disabled = i === list.customOrder.length - 1;
      down.addEventListener("click", function () {
        moveEntryInList(list.id, id, +1);
      });

      controls.appendChild(up);
      controls.appendChild(down);

      item.appendChild(t);
      item.appendChild(controls);
      listBox.appendChild(item);
    }

    panel.appendChild(listBox);

    const note = document.createElement("p");
    note.className = "settings-copy";
    note.textContent = "Reordering updates the list‚Äôs custom order. On mobile, use the arrows.";
    panel.appendChild(note);
  }
}

      function getViewsForActiveList() {
  const list = getListById(state.listsUi && state.listsUi.activeListId ? state.listsUi.activeListId : null);
  if (!list) return [];

  const term = state.searchTerm ? state.searchTerm.trim().toLowerCase() : "";

  // Smart list uses cached TMDB results
  if (list.type === "smart") {
    let raw = Array.isArray(list.cachedResults) ? list.cachedResults.slice() : [];
    if (term) {
      const tmp = [];
      for (let i = 0; i < raw.length; i++) {
        const t = ((raw[i].title || raw[i].name || "")).toLowerCase();
        if (t.indexOf(term) !== -1) tmp.push(raw[i]);
      }
      raw = tmp;
    }

    const views = [];
    for (let i = 0; i < raw.length; i++) {
      const m = raw[i];
      const mt = inferMediaTypeFromTmdb(m, "movie");
const linked = linkSavedItemFromTmdb(m, mt);
views.push({ mode: "remote", tmdbMovie: m, item: linked, mediaType: mt });
}
    return applyFiltersAndSort(views);
  }

  // Manual list
  let entries = Array.isArray(list.entries) ? list.entries.slice() : [];
  if (term) {
    const tmp = [];
    for (let i = 0; i < entries.length; i++) {
      const t = (entries[i].title || "").toLowerCase();
      if (t.indexOf(term) !== -1) tmp.push(entries[i]);
    }
    entries = tmp;
  }

  // Apply per-list sorting
  const sortMode = list.sortMode || "custom";
  if (sortMode === "custom") {
    ensureCustomOrder(list);
    const map = {};
    for (let i = 0; i < entries.length; i++) map[entries[i].tmdbId] = entries[i];
    const ordered = [];
    for (let i = 0; i < list.customOrder.length; i++) {
      const id = list.customOrder[i];
      if (map[id]) ordered.push(map[id]);
    }
    // any extras (shouldn't happen)
    for (let i = 0; i < entries.length; i++) {
      if (ordered.indexOf(entries[i]) === -1) ordered.push(entries[i]);
    }
    entries = ordered;
  } else if (sortMode === "rating") {
    entries.sort(function (a, b) { return (b.rating || 0) - (a.rating || 0); });
  } else if (sortMode === "year") {
    entries.sort(function (a, b) { return parseInt(b.year || "0", 10) - parseInt(a.year || "0", 10); });
  } else if (sortMode === "title") {
    entries.sort(function (a, b) { return String(a.title || "").localeCompare(String(b.title || ""), "en-GB"); });
  }

  const views = [];
  for (let i = 0; i < entries.length; i++) {
    const e = entries[i];
    const linked = findItemByTmdbId(e.tmdbId, normaliseMediaType(e.mediaType || "movie"));
    views.push({
      mode: "remote",
      tmdbMovie: {
        id: e.tmdbId,
        title: e.title,
        release_date: e.year ? (e.year + "-01-01") : "",
        poster_path: e.posterPath,
        vote_average: typeof e.rating === "number" ? e.rating : 0,
        popularity: 0
      },
      item: linked,
      mediaType: normaliseMediaType(e.mediaType || "movie"),
      __listEntry: true
    });
  }

  return applyFiltersAndSort(views);
}

      function updateCopyForTab() {
        let title = "";
        let subtitle = "";
        let placeholder = "";

        if (state.activeTab === "for-you") {
          title = "For You";
          subtitle = "Suggestions based on your favourite genres (or popular picks if you haven‚Äôt chosen any yet).";
          placeholder = "Search within your recommendations‚Ä¶";
        } else if (state.activeTab === "discover") {
          title = "Discover";
          if (state.discoverMode === "because") {
            subtitle = "Because you liked ‚Äú" + state.discoverSeedTitle + "‚Äù.";
          } else {
            subtitle = "Explore the latest in cinema.";
          }
          placeholder = "Search titles, directors, genres‚Ä¶";
        } else if (state.activeTab === "radar") {
          title = "Radar";
          subtitle = "Upcoming releases worth keeping an eye on.";
          placeholder = "Search upcoming releases‚Ä¶";
        } else if (state.activeTab === "watchlist") {
          title = "Watchlist";
          subtitle = "Films you‚Äôve saved to watch later.";
          placeholder = "Search your watchlist‚Ä¶";
        } else if (state.activeTab === "rewatch") {
          title = "Rewatch";
          subtitle = "Films you‚Äôve marked for a rewatch.";
          placeholder = "Search your rewatch list‚Ä¶";
        } else if (state.activeTab === "watched") {
          title = "Watched";
          subtitle = "Everything you‚Äôve already seen.";
          placeholder = "Search your watched list‚Ä¶";
        } else if (state.activeTab === "lists") {
          title = "Lists";
          subtitle = "Create and curate your own collections.";
          placeholder = "Search within your lists‚Ä¶";
        } else if (state.activeTab === "settings") {
          title = "Settings";
          subtitle = "Tune ReelQuest to your taste.";
          placeholder = "Search is not used in Settings.";
        } else if (state.activeTab === "account") {
          title = "Account";
          subtitle = "Sign in to sync your ReelQuest across devices.";
          placeholder = "Search is not used in Account.";
        }

        els.sectionTitle.textContent = title;
        els.sectionSubtitle.textContent = subtitle;
        els.searchInput.placeholder = placeholder;
      }

      function getEmptyMessageForTab() {
        if (state.activeTab === "for-you") {
          if (!state.favouriteGenres.length) {
            return "Pick favourite genres in Settings for personalised recommendations ‚Äî otherwise we‚Äôll show popular films.";
          }
          if (state.forYouLoaded && (!state.forYouResults || !state.forYouResults.length)) {
            return "We couldn‚Äôt find any recommendations right now. Try different genres.";
          }
          return "";
        }

        const views = getViewItemsForCurrentTab();
        try { ensureStreamingInfoForVisible(views); } catch (e) {}
        if (views.length > 0) return "";

        if (state.activeTab === "radar") {
          const term = state.searchTerm ? state.searchTerm.trim().toLowerCase() : "";
          let raw = state.radarResults || [];
          if (term) {
            const filtered = [];
            for (let i = 0; i < raw.length; i++) {
              const m = raw[i];
              const t = (m.title || "").toLowerCase();
              if (t.indexOf(term) !== -1) filtered.push(m);
            }
            raw = filtered;
          }
          const views = [];
          for (let i = 0; i < raw.length; i++) {
            const m = raw[i];
            const mt = inferMediaTypeFromTmdb(m, "movie");
const linked = linkSavedItemFromTmdb(m, mt);
views.push({ mode: "remote", tmdbMovie: m, item: linked, mediaType: mt });
}
          return applyFiltersAndSort(views);
        }

        if (state.activeTab === "discover") {
          return "Search TMDB to start discovering films.";
        }
        if (state.activeTab === "watchlist") {
          return "Your watchlist is empty. Tap + on any film to add it.";
        }
        if (state.activeTab === "watched") {
          return "You haven‚Äôt marked anything as watched yet.";
        }
        if (state.activeTab === "lists") {
          if (!state.listsUi || state.listsUi.mode === "index") {
            return "Create a list above to start collecting films.";
          }
          return "This list is empty. Add films from Discover or For You.";
        }
        return "";
      }

      function createCard(view) {
        const mode = view.mode;
        const item = view.item;
        const tmdbMovie = view.tmdbMovie;
        const isLocal = mode === "local";

        let title;
        if (isLocal) {
          if (item.year) {
            title = item.title + " (" + item.year + ")";
          } else {
            title = item.title;
          }
        } else if (tmdbMovie) {
          const y = yearFromTmdb(tmdbMovie);
          const baseTitle = titleFromTmdb(tmdbMovie);
          title = y ? (baseTitle + " (" + y + ")") : baseTitle;
        } else {
          title = "";
        }

        let posterPath = null;
        if (isLocal) {
          posterPath = item.posterPath;
        } else if (tmdbMovie && tmdbMovie.poster_path) {
          posterPath = tmdbMovie.poster_path;
        }

        const rating = ratingFromView(view);

        const inWatchlist = isLocal
          ? item.inWatchlist
          : view.item
          ? view.item.inWatchlist
          : false;

        const watched = isLocal
          ? item.watched
          : view.item
          ? view.item.watched
          : false;

        const card = document.createElement("article");
        card.className = "movie-card";

        const posterWrapper = document.createElement("div");
        posterWrapper.className = "poster-wrapper";

        if (posterPath) {
          const img = document.createElement("img");
          img.className = "poster-img";
          img.src = "https://image.tmdb.org/t/p/w342" + posterPath;
          img.alt = title;
          posterWrapper.appendChild(img);
        } else {
          const placeholder = document.createElement("div");
          placeholder.className = "poster-fallback";
          placeholder.textContent = "üé¨";
          posterWrapper.appendChild(placeholder);
        }

        const mt = isLocal
  ? normaliseMediaType(item.mediaType || "movie")
  : inferMediaTypeFromTmdb(tmdbMovie || {}, view.mediaType || "movie");
        if (mt === "tv") {
          const tp = document.createElement("div");
          tp.className = "type-pill";
          tp.textContent = "TV";
          posterWrapper.appendChild(tp);
        }

        if (rating && !Number.isNaN(rating)) {
          const pill = document.createElement("div");
          pill.className = "rating-pill";
          pill.innerHTML = "‚òÖ <span>" + rating.toFixed(1) + "</span>";
          posterWrapper.appendChild(pill);
        }

// Watch progress status badge (watchlist items that aren't watched)
let statusItem = null;
if (isLocal) {
  statusItem = item;
} else {
  statusItem = (view && view.item) ? view.item : linkSavedItemFromTmdb(tmdbMovie || {}, mt);
}

if (statusItem && statusItem.inWatchlist && !statusItem.watched) {
  const st = normaliseWatchStatus(statusItem.status);

  // Outside the Watchlist tab, "Planned" can feel noisy, so show a compact badge.
  // This also stops the UI feeling "random" when lots of items are still Planned.
  const compactPlanned = (st === "planned" && state.activeTab !== "watchlist");

  const sp = document.createElement("div");
  sp.className = "status-pill status-" + st;
  sp.textContent = compactPlanned ? "WL" : WATCH_PROGRESS_STATUS_LABELS[st];
  sp.title = WATCH_PROGRESS_STATUS_LABELS[st];
  posterWrapper.appendChild(sp);
}


        const actions = document.createElement("div");
        actions.className = "poster-actions";

        const eyeBtn = document.createElement("button");
        eyeBtn.type = "button";
        eyeBtn.className =
          "card-btn card-btn-eye" + (watched ? " active" : "");
        eyeBtn.title = watched ? "Mark as not watched" : "Mark as watched";
        eyeBtn.textContent = "üëÅ";

        const plusBtn = document.createElement("button");
        plusBtn.type = "button";
        plusBtn.className =
          "card-btn card-btn-plus" + (inWatchlist ? " active" : "");
        plusBtn.title = inWatchlist
          ? "Remove from watchlist"
          : "Add to watchlist";
        plusBtn.textContent = "+";

        actions.appendChild(eyeBtn);
        actions.appendChild(plusBtn);

        if (state.activeTab === "radar" && tmdbMovie && tmdbMovie.release_date) {
          const calBtn = document.createElement("button");
          calBtn.type = "button";
          calBtn.className = "card-btn";
          calBtn.title = "Add release reminder";
          calBtn.textContent = "üóì";
          calBtn.addEventListener("click", function (e) {
            e.stopPropagation();
            downloadIcsReminder(tmdbMovie.title, tmdbMovie.release_date);
          });
          actions.appendChild(calBtn);
        }

        if (state.activeTab === "lists" && state.listsUi && state.listsUi.mode === "detail" && tmdbMovie && tmdbMovie.id) {
          const removeBtn = document.createElement("button");
          removeBtn.type = "button";
          removeBtn.className = "card-btn";
          removeBtn.title = "Remove from list";
          removeBtn.textContent = "‚àí";
          removeBtn.addEventListener("click", function (e) {
            e.stopPropagation();
            if (state.listsUi && state.listsUi.activeListId) {
              removeTmdbFromList(state.listsUi.activeListId, tmdbMovie.id);
            }
          });
          actions.appendChild(removeBtn);
        }
        posterWrapper.appendChild(actions);

        const titleLine = document.createElement("div");
        titleLine.className = "movie-title-line";
        titleLine.textContent = title;

const subline = document.createElement("div");
subline.className = "movie-subline";

if (isLocal) {
  const bits = [];
  if (item.inWatchlist) {
    bits.push("On your watchlist");
    const p = item.priority || "medium";
    if (p === "high") bits.push("Priority: High");
    else if (p === "low") bits.push("Priority: Low");
    else bits.push("Priority: Medium");

if (Array.isArray(item.tags) && item.tags.length) {
  const show = item.tags.slice(0, 2).join(", ");
  bits.push("Tags: " + show + (item.tags.length > 2 ? "‚Ä¶" : ""));
}
if (item.notes && String(item.notes).trim()) {
  bits.push("Notes");
}
  }
  if (item.watched) {
    bits.push("Watched");
    if (item.rewatch) bits.push("Rewatch");
    if (item.watchedAt) bits.push("Watched on " + formatDateUK(item.watchedAt));
    if (typeof item.userRating === "number") bits.push("Your rating " + item.userRating.toFixed(1) + "/10");
  }
  if (!bits.length) {
    if (rating) bits.push("TMDB ¬∑ " + rating.toFixed(1) + "‚òÖ");
    else bits.push("TMDB");
  }
  subline.textContent = bits.join(" ¬∑ ");
} else if (rating) {
  subline.textContent = "TMDB ¬∑ " + rating.toFixed(1) + "‚òÖ";
} else {
  subline.textContent = "TMDB";
}

        card.appendChild(posterWrapper);
        card.appendChild(titleLine);
        card.appendChild(subline);

        posterWrapper.addEventListener("click", function () {
          openDetailForView(view);
        });

        eyeBtn.addEventListener("click", function (e) {
          e.stopPropagation();
          if (isLocal) {
            toggleWatchedForItem(item);
          } else if (tmdbMovie) {
            const linked = ensureItemFromTmdb(tmdbMovie, view.mediaType || (tmdbMovie && tmdbMovie.media_type));
            toggleWatchedForItem(linked);
          }
        });

        plusBtn.addEventListener("click", function (e) {
          e.stopPropagation();
          if (isLocal) {
            toggleWatchlistForItem(item);
          } else if (tmdbMovie) {
            const linked = ensureItemFromTmdb(tmdbMovie, view.mediaType || (tmdbMovie && tmdbMovie.media_type));
            toggleWatchlistForItem(linked);
          }
        });

        card.addEventListener("click", function (e) {
          if (bulkSelectable && state.ui.selectionMode) {
            const t = e.target;
            if (t && (t.closest(".card-btn") || t.closest(".pill-btn") || t.closest("a"))) return;
            if (tmdbIdForSelect) toggleSelectedKey(tmdbIdForSelect);
          }
        });

        return card;
      }

      function renderListActions() {
        const container = els.listActions;
        container.innerHTML = "";

        // Bulk selection controls
        if (isBulkSelectableTab()) {
          const selectBtn = document.createElement("button");
          selectBtn.type = "button";
          selectBtn.className = "pill-btn";
          selectBtn.textContent = state.ui.selectionMode ? "Done selecting" : "Select";
          selectBtn.addEventListener("click", function () {
            state.ui.selectionMode = !state.ui.selectionMode;
            if (!state.ui.selectionMode) state.ui.selectedKeys = [];
            saveState();
            render();
          });
          container.appendChild(selectBtn);

          if (state.ui.selectionMode) {
            const bar = document.createElement("div");
            bar.className = "bulk-bar";

            const count = document.createElement("span");
            count.className = "bulk-count";
            count.textContent = (state.ui.selectedKeys.length || 0) + " selected";
            bar.appendChild(count);

            const selectAllBtn = document.createElement("button");
            selectAllBtn.type = "button";
            selectAllBtn.className = "pill-btn";
            selectAllBtn.textContent = "Select all";
            selectAllBtn.addEventListener("click", function () {
              const views = getViewItemsForCurrentTab();
              const ids = [];
              for (let i = 0; i < views.length; i++) {
                const id = getKeyFromView(views[i]);
                if (id) ids.push(id);
              }
              state.ui.selectedKeys = ids;
              saveState();
              render();
            });
            bar.appendChild(selectAllBtn);

            const clearBtn = document.createElement("button");
            clearBtn.type = "button";
            clearBtn.className = "pill-btn";
            clearBtn.textContent = "Clear";
            clearBtn.addEventListener("click", function () {
              state.ui.selectedKeys = [];
              saveState();
              render();
            });
            bar.appendChild(clearBtn);

            const moveBtn = document.createElement("button");
            moveBtn.type = "button";
            moveBtn.className = "pill-btn";
            moveBtn.textContent = "Move to watched";
            moveBtn.addEventListener("click", function () {
              const views = getSelectedViewsForCurrentTab();
              if (!views.length) { toast("Select at least one film first."); return; }
              bulkMoveSelectedToWatched(views);
              clearSelection();
            });
            bar.appendChild(moveBtn);

            const addListBtn = document.createElement("button");
            addListBtn.type = "button";
            addListBtn.className = "pill-btn";
            addListBtn.textContent = "Add to list";
            addListBtn.addEventListener("click", function () {
              const views = getSelectedViewsForCurrentTab();
              if (!views.length) { toast("Select at least one film first."); return; }
              openBulkAddToListPicker(views);
            });
            bar.appendChild(addListBtn);

            const removeBtn = document.createElement("button");
            removeBtn.type = "button";
            removeBtn.className = "pill-btn";
            removeBtn.textContent = "Remove";
            removeBtn.addEventListener("click", function () {
              const views = getSelectedViewsForCurrentTab();
              if (!views.length) { toast("Select at least one film first."); return; }
              bulkRemoveSelectedFromContext(views);
              clearSelection();
            });
            bar.appendChild(removeBtn);

            container.appendChild(bar);
          }
        }

        if (state.activeTab === "watchlist") {
          const clearBtn = document.createElement("button");
          clearBtn.type = "button";
          clearBtn.className = "pill-btn";
          clearBtn.textContent = "Clear watchlist";
          clearBtn.addEventListener("click", clearWatchlist);
          container.appendChild(clearBtn);

          const shareBtn = document.createElement("button");
          shareBtn.type = "button";
          shareBtn.className = "pill-btn";
          shareBtn.textContent = "Share watchlist";
          shareBtn.addEventListener("click", shareWatchlist);
          container.appendChild(shareBtn);

const pickBtn = document.createElement("button");
pickBtn.type = "button";
pickBtn.className = "pill-btn";
pickBtn.textContent = "Pick something for me";
pickBtn.addEventListener("click", pickFromWatchlist);
container.appendChild(pickBtn);
        } else if (state.activeTab === "rewatch") {
          title = "Rewatch";
          subtitle = "Films you‚Äôve marked for a rewatch.";
          placeholder = "Search your rewatch list‚Ä¶";
        } else if (state.activeTab === "rewatch") {
          const clearRewatchBtn = document.createElement("button");
          clearRewatchBtn.type = "button";
          clearRewatchBtn.className = "pill-btn";
          clearRewatchBtn.textContent = "Clear rewatch";
          clearRewatchBtn.addEventListener("click", function () {
            if (!window.confirm("Clear your rewatch list? This won‚Äôt delete watched history.")) return;
            for (let i = 0; i < state.items.length; i++) {
              if (state.items[i]) state.items[i].rewatch = false;
            }
            saveState();
            render();
          });
          container.appendChild(clearRewatchBtn);
        } else if (state.activeTab === "watched") {
          const clearWatchedBtn = document.createElement("button");
          clearWatchedBtn.type = "button";
          clearWatchedBtn.className = "pill-btn";
          clearWatchedBtn.textContent = "Clear watched";
          clearWatchedBtn.addEventListener("click", clearWatched);
          container.appendChild(clearWatchedBtn);
        }
      }

      function render() {
        updateCopyForTab();

        for (let i = 0; i < els.tabButtons.length; i++) {
          const btn = els.tabButtons[i];
          btn.classList.toggle("active", btn.dataset.tab === state.activeTab);
        }

        if (els.sortSelect) els.sortSelect.value = state.sortBy;
        if (els.ratingFilterSelect) els.ratingFilterSelect.value = String(state.minRating);
        if (els.moodSelect) els.moodSelect.value = state.mood || "any";
        if (els.streamingSelect) els.streamingSelect.value = state.streamingMode || "any";


        if (state.activeTab === "account") {
          els.searchForm.style.display = "none";
          els.controlsBar.style.display = "none";
          els.message.style.display = "none";
          els.grid.style.display = "none";
          els.settingsPanel.style.display = "none";
          if (els.accountPanel) els.accountPanel.style.display = "none";
          if (els.listsPanel) els.listsPanel.style.display = "none";
          if (els.accountPanel) els.accountPanel.style.display = "block";
          renderAccount();
          renderListActions();
          if (state.lastTmdbStatus) updateDebug(state.lastTmdbStatus);
          return;
        }

        if (state.activeTab === "settings") {
          els.searchForm.style.display = "none";
          els.controlsBar.style.display = "none";
          els.message.style.display = "none";
          els.grid.style.display = "none";
          els.settingsPanel.style.display = "block";
          if (els.listsPanel) els.listsPanel.style.display = "none";
          renderSettings();
          renderListActions();
          if (state.lastTmdbStatus) updateDebug(state.lastTmdbStatus);
          return;
        }

        if (state.activeTab === "lists") {
          els.searchForm.style.display = "block";
          els.controlsBar.style.display = (state.listsUi && state.listsUi.mode === "detail") ? "flex" : "none";
          els.message.style.display = "none";
          els.grid.style.display = (state.listsUi && state.listsUi.mode === "detail") ? "grid" : "none";
          els.settingsPanel.style.display = "none";
        if (els.listsPanel) els.listsPanel.style.display = "none";
        if (els.accountPanel) els.accountPanel.style.display = "none";
          els.listsPanel.style.display = "block";
          renderListsPanel();

          if (state.listsUi && state.listsUi.mode === "detail") {
            const views = getViewsForActiveList();
            els.grid.innerHTML = "";
            const emptyMessage = getEmptyMessageForTab();
            if (views.length === 0 && emptyMessage) {
              els.message.style.display = "block";
              els.message.textContent = emptyMessage;
            } else {
              els.message.style.display = "none";
              els.message.textContent = "";
            }
            for (let i = 0; i < views.length; i++) {
              const card = createCard(views[i]);
              els.grid.appendChild(card);
            }
          } else {
            els.grid.innerHTML = "";
            els.message.style.display = "none";
            els.message.textContent = "";
          }

          renderListActions();
          if (state.lastTmdbStatus) updateDebug(state.lastTmdbStatus);
          return;
        }

        els.searchForm.style.display = "block";
        els.controlsBar.style.display = "flex";
        els.grid.style.display = "grid";
        els.settingsPanel.style.display = "none";
        if (els.listsPanel) els.listsPanel.style.display = "none";

        const views = getViewItemsForCurrentTab();
        els.grid.innerHTML = "";

        const emptyMessage = getEmptyMessageForTab();

        if (state.localMoodLoading) {
          els.message.style.display = "block";
          els.message.textContent = "Fetching genre info so Mood filtering works on your saved lists‚Ä¶";
        } else if (state.streamingLoading && streamingPref() !== "any") {
          els.message.style.display = "block";
          els.message.textContent = "Checking streaming availability for this list‚Ä¶";
        } else if (state.activeTab === "for-you" && state.forYouLoading) {
          els.message.style.display = "block";
          els.message.textContent =
            "Fetching recommendations based on your favourite genres‚Ä¶";
        } else if (views.length === 0 && emptyMessage) {
          els.message.style.display = "block";
          els.message.textContent = emptyMessage;
        } else {
          if (emptyMessage) {
            els.message.style.display = "block";
            els.message.textContent = emptyMessage;
          } else {
            els.message.style.display = "none";
            els.message.textContent = "";
          }
        }

        for (let i = 0; i < views.length; i++) {
          const card = createCard(views[i]);
          els.grid.appendChild(card);
        }

        if (state.lastTmdbStatus) {
          updateDebug(state.lastTmdbStatus);
        }

        renderListActions();
      }

      function handleTabClick(e) {
        const tab = e.currentTarget.dataset.tab;
        switchToTab(tab);
      }

      function handleSearchInput(e) {
        try {
          state.searchTerm = (e && e.target && typeof e.target.value === "string") ? e.target.value : "";
        } catch (err) {
          state.searchTerm = "";
        }
        // Filtering is handled in getViewItemsForCurrentTab(); just re-render.
        render();
      }

      function handleSearchSubmit(e) {
        e.preventDefault();
        if (state.activeTab === "discover") {
          performDiscoverSearch();
        } else {
          render();
        }
      }

      function handleSortChange(e) {
        state.sortBy = e.target.value || "default";
        saveState();
        render();
      }

      function handleRatingFilterChange(e) {
        const val = parseFloat(e.target.value || "0");
        state.minRating = isNaN(val) ? 0 : val;
        saveState();
        render();
      }

function localItemsForActiveTab() {
  const out = [];
  const tab = state.activeTab;
  if (tab === "watchlist") {
    for (let i = 0; i < state.items.length; i++) if (state.items[i] && state.items[i].inWatchlist) out.push(state.items[i]);
  } else if (tab === "watched") {
    for (let i = 0; i < state.items.length; i++) if (state.items[i] && state.items[i].watched) out.push(state.items[i]);
  } else if (tab === "rewatch") {
    for (let i = 0; i < state.items.length; i++) if (state.items[i] && state.items[i].rewatch) out.push(state.items[i]);
  } else {
    return out;
  }
  return out;
}

function ensureDetailsForLocalTab() {
  try {
    if (getMoodKey() === "any") return;
    const tab = state.activeTab;
    const isLocalTab = (tab === "watchlist" || tab === "watched" || tab === "rewatch");
    if (!isLocalTab) return;
    if (isOffline()) {
      toast("Mood filtering needs a connection to fetch genre info.");
      return;
    }

    const items = localItemsForActiveTab();
    const toFetch = [];
    for (let i = 0; i < items.length; i++) {
      const it = items[i];
      if (!it) continue;
      const idNum = toTmdbId(it.tmdbId);
      if (idNum === null) continue;
      const mt = normaliseMediaType(it.mediaType || "movie");
      const cacheKey = mt + ":" + idNum;
      if (!state.detailsCache || !state.detailsCache[cacheKey]) {
        toFetch.push({ tmdbId: idNum, mediaType: mt });
      }
    }

    if (!toFetch.length) return;

    state.localMoodLoading = true;
    render();

    (async function () {
      for (let i = 0; i < toFetch.length; i += 4) {
        const chunk = toFetch.slice(i, i + 4);
        await Promise.all(chunk.map(function (t) {
          return fetchDetails(t.tmdbId, t.mediaType).catch(function () { return null; });
        }));
      }
      state.localMoodLoading = false;
      render();
    })();
  } catch (e) {
    console.error(e);
    state.localMoodLoading = false;
    render();
  }
}


function handleMoodChange(e) {
  const v = String((e && e.target && e.target.value) || "any");
  state.mood = MOODS[v] ? v : "any";
  saveState();

  if (state.activeTab === "discover") {
    loadPopularForDiscover();
  } else if (state.activeTab === "for-you") {
    loadForYouRecommendations();
  } else if (state.activeTab === "radar") {
    loadRadarUpcoming();
  } else {
    if (getMoodKey() !== "any") {
      ensureDetailsForLocalTab();
    } else {
      render();
    }
  }
}

function handleStreamingModeChange(e) {
  const val = (e && e.target && typeof e.target.value === "string") ? e.target.value : "any";
  state.streamingMode = (val === "first" || val === "only") ? val : "any";
  saveState();
  render();
}

      async function fetchWatchProviders(tmdbId, mediaType) {
  const mt = normaliseMediaType(mediaType);
  const url = new URL("https://api.themoviedb.org/3/" + (mt === "tv" ? "tv" : "movie") + "/" + tmdbId + "/watch/providers");
  url.searchParams.set("api_key", TMDB_API_KEY);
  const data = await tmdbFetch(url);
  return data && data.results ? data.results : {};
}

      async function fetchDetails(tmdbId, mediaType) {
  if (!tmdbId) throw new Error("No TMDB id");
  const mt = normaliseMediaType(mediaType);
  const cacheKey = mt + ":" + tmdbId;
  if (state.detailsCache[cacheKey]) return state.detailsCache[cacheKey];

  const url = new URL("https://api.themoviedb.org/3/" + (mt === "tv" ? "tv" : "movie") + "/" + tmdbId);
  url.searchParams.set("api_key", TMDB_API_KEY);
  url.searchParams.set("language", "en-GB");
  url.searchParams.set("append_to_response", "videos");

  const data = await tmdbFetch(url);
  state.detailsCache[cacheKey] = data;
  return data;
}

      function closeDetail() {
        els.detailOverlay.classList.add("hidden");
        els.detailOverlay.setAttribute("aria-hidden", "true");
      }

      async function openDetailForView(view) {
        let tmdbId = null;
        let mediaType = "movie";
        if (view.mode === "local") {
          tmdbId = view.item.tmdbId;
          mediaType = normaliseMediaType(view.item.mediaType || "movie");
        } else if (view.tmdbMovie) {
          tmdbId = view.tmdbMovie.id;
          mediaType = normaliseMediaType(view.mediaType || view.tmdbMovie.media_type || "movie");
        }

        if (!tmdbId) {
          alertNice("No extra details available for this title.");
          return;
        }

        els.detailTitle.textContent = "Loading‚Ä¶";
        els.detailMeta.textContent = "";
        els.detailPoster.innerHTML = "";
        els.detailOverview.textContent = "";
        els.detailChips.innerHTML = "";
        els.detailActions.innerHTML = "";
        els.detailLinks.innerHTML = "";
        els.detailOverlay.classList.remove("hidden");
        els.detailOverlay.setAttribute("aria-hidden", "false");

        try {
          const details = await fetchDetails(tmdbId, mediaType);

          const year = (details.release_date || details.first_air_date)
            ? String(details.release_date || details.first_air_date).slice(0, 4)
            : "";
          let title = "";
          if (details.title) {
            title = details.title;
          } else if (view.item && view.item.title) {
            title = view.item.title;
          } else {
            title = "Untitled";
          }
          const runtime = details.runtime ? details.runtime + " min" : "";
          const genresText = (details.genres || [])
            .map(function (g) {
              return g.name;
            })
            .join(", ");

          els.detailTitle.textContent = year ? title + " (" + year + ")" : title;

          const metaParts = [];
          if (details.vote_average) {
            metaParts.push("TMDB " + details.vote_average.toFixed(1) + "‚òÖ");
          }
          if (runtime) metaParts.push(runtime);
          if (genresText) metaParts.push(genresText);
          els.detailMeta.textContent = metaParts.join(" ¬∑ ");

          if (details.poster_path) {
            const img = document.createElement("img");
            img.src = "https://image.tmdb.org/t/p/w342" + details.poster_path;
            img.alt = title;
            els.detailPoster.innerHTML = "";
            els.detailPoster.appendChild(img);
          }

          const overview =
            details.overview ||
            (view.tmdbMovie && view.tmdbMovie.overview) ||
            "No synopsis available yet.";
          els.detailOverview.textContent = overview;

          const chips = [];
          if (details.release_date) {
            chips.push("Released " + details.release_date);
          }
          if (details.original_language) {
            chips.push(
              "Original language: " + details.original_language.toUpperCase()
            );
          }
          const genres = details.genres || [];
          for (let i = 0; i < genres.length; i++) {
            chips.push(genres[i].name);
          }

          for (let i = 0; i < chips.length; i++) {
            const chip = document.createElement("span");
            chip.className = "detail-chip";
            chip.textContent = chips[i];
            els.detailChips.appendChild(chip);
          }

          const linked =
            view.mode === "local" && view.item
              ? view.item
              : ensureItemFromTmdb(details, mediaType);

          const watchBtn = document.createElement("button");
          watchBtn.type = "button";
          watchBtn.className = "pill-btn";
          watchBtn.textContent = linked.inWatchlist
            ? "Remove from watchlist"
            : "Add to watchlist";
          watchBtn.addEventListener("click", function () {
            toggleWatchlistForItem(linked);
            watchBtn.textContent = linked.inWatchlist
              ? "Remove from watchlist"
              : "Add to watchlist";
          });

          const watchedBtn = document.createElement("button");
          watchedBtn.type = "button";
          watchedBtn.className = "pill-btn";
          watchedBtn.textContent = linked.watched
            ? "Mark as not watched"
            : "Mark as watched";
          watchedBtn.addEventListener("click", function () {
            toggleWatchedForItem(linked);
            watchedBtn.textContent = linked.watched
              ? "Mark as not watched"
              : "Mark as watched";
          });

          els.detailActions.appendChild(watchBtn);
          els.detailActions.appendChild(watchedBtn);

          // Lists: add this film to one of your custom lists
          const listBlock = document.createElement("div");
          listBlock.style.display = "flex";
          listBlock.style.flexWrap = "wrap";
          listBlock.style.gap = "8px";
          listBlock.style.alignItems = "center";
          listBlock.style.marginTop = "10px";

          const listLabel = document.createElement("span");
          listLabel.textContent = "List:";
          listLabel.style.fontSize = "12px";
          listLabel.style.color = "var(--text-muted)";
          listBlock.appendChild(listLabel);

          if (state.lists && state.lists.length) {
            const select = document.createElement("select");
            select.className = "controls-select";
            select.style.borderRadius = "14px";
            select.style.padding = "6px 10px";
            select.style.minWidth = "160px";

            // Prefer currently-open list if you're in Lists > detail
            let preferredId = null;
            if (state.activeTab === "lists" && state.listsUi && state.listsUi.mode === "detail") {
              preferredId = state.listsUi.activeListId;
            }

            for (let i = 0; i < state.lists.length; i++) {
              const l = state.lists[i];
              const opt = document.createElement("option");
              opt.value = l.id;
              opt.textContent = l.name;
              select.appendChild(opt);
            }

            if (preferredId) {
              for (let i = 0; i < select.options.length; i++) {
                if (select.options[i].value === preferredId) {
                  select.selectedIndex = i;
                  break;
                }
              }
            }

            const addBtn = document.createElement("button");
            addBtn.type = "button";
            addBtn.className = "pill-btn";
            addBtn.textContent = "Add to list";
            addBtn.addEventListener("click", function () {
              const listId = select.value;
              addTmdbToList(listId, details, mediaType);
              alertNice("Added to your list.");
            });

            const openListsBtn = document.createElement("button");
            openListsBtn.type = "button";
            openListsBtn.className = "pill-btn";
            openListsBtn.textContent = "View lists";
            openListsBtn.addEventListener("click", function () {
              closeDetail();
              switchToTab("lists");
            });

            listBlock.appendChild(select);
            listBlock.appendChild(addBtn);
            listBlock.appendChild(openListsBtn);
          } else {
            const createBtn = document.createElement("button");
            createBtn.type = "button";
            createBtn.className = "pill-btn";
            createBtn.textContent = "Create a list";
            createBtn.addEventListener("click", function () {
              closeDetail();
              switchToTab("lists");
            });
            listBlock.appendChild(createBtn);
          }

          els.detailActions.appendChild(listBlock);

          const moreBtn = document.createElement("button");
          moreBtn.type = "button";
          moreBtn.className = "pill-btn";
          moreBtn.textContent = "More like this";
          moreBtn.addEventListener("click", function () {
            closeDetail();
            loadBecauseYouLiked(details.id, title, mediaType);
          });
          els.detailActions.appendChild(moreBtn);

          // Organise (notes, tags, priority, rating, rewatch)
const orgWrap = document.createElement("div");
orgWrap.className = "detail-card";

const orgHeading = document.createElement("div");
orgHeading.className = "detail-kicker";
orgHeading.textContent = "Organise";
orgWrap.appendChild(orgHeading);

const orgGrid = document.createElement("div");
orgGrid.className = "organise-grid";
orgWrap.appendChild(orgGrid);

// Priority (useful for watchlist)
const priRow = document.createElement("div");
priRow.className = "organise-row";
priRow.style.flexWrap = "wrap";
priRow.style.gap = "8px";
priRow.style.alignItems = "center";
priRow.style.marginTop = "8px";

const priLabel = document.createElement("span");
priLabel.textContent = "Priority:";
priLabel.style.fontSize = "12px";
priLabel.style.color = "var(--text-muted)";
priRow.appendChild(priLabel);

function makePriBtn(key, label) {
  const b = document.createElement("button");
  b.type = "button";
  b.className = "pill-btn";
  b.textContent = label;
  b.addEventListener("click", function () {
    linked.priority = key;
    saveState();
    render();
    // update button styles
    lowBtn.classList.toggle("active", linked.priority === "low");
    medBtn.classList.toggle("active", linked.priority === "medium");
    highBtn.classList.toggle("active", linked.priority === "high");
  });
  return b;
}

const lowBtn = makePriBtn("low", "Low");
const medBtn = makePriBtn("medium", "Medium");
const highBtn = makePriBtn("high", "High");

lowBtn.classList.toggle("active", linked.priority === "low");
medBtn.classList.toggle("active", linked.priority === "medium");
highBtn.classList.toggle("active", linked.priority === "high");

priRow.appendChild(lowBtn);
priRow.appendChild(medBtn);
priRow.appendChild(highBtn);

orgGrid.appendChild(priRow);

// Status (Planned / Started / Paused / Abandoned) ‚Äî only for watchlist items that aren't watched
if (linked.inWatchlist && !linked.watched) {
  const statusRow = document.createElement("div");
  statusRow.className = "organise-row";
  statusRow.style.flexWrap = "wrap";
  statusRow.style.gap = "8px";
  statusRow.style.alignItems = "center";
  statusRow.style.marginTop = "8px";

  const statusLabel = document.createElement("span");
  statusLabel.textContent = "Status:";
  statusLabel.style.fontSize = "12px";
  statusLabel.style.color = "var(--text-muted)";
  statusRow.appendChild(statusLabel);

  const statusSelect = document.createElement("select");
  statusSelect.className = "controls-select";
  statusSelect.style.borderRadius = "14px";
  statusSelect.style.padding = "6px 10px";
  statusSelect.style.minWidth = "180px";

  for (let i = 0; i < WATCH_PROGRESS_STATUS_KEYS.length; i++) {
    const k = WATCH_PROGRESS_STATUS_KEYS[i];
    const opt = document.createElement("option");
    opt.value = k;
    opt.textContent = WATCH_PROGRESS_STATUS_LABELS[k];
    statusSelect.appendChild(opt);
  }

  statusSelect.value = normaliseWatchStatus(linked.status);

  statusSelect.addEventListener("change", function () {
    linked.status = normaliseWatchStatus(statusSelect.value);
    saveState();
    render();
  });

  statusRow.appendChild(statusSelect);

  const hint = document.createElement("span");
  hint.style.fontSize = "12px";
  hint.style.color = "var(--text-muted)";
  hint.textContent = "Helps keep your watchlist honest.";
  statusRow.appendChild(hint);

  orgGrid.appendChild(statusRow);
}




// Tags (with autocomplete from existing tags)
const tagRow = document.createElement("div");
tagRow.className = "organise-row";
tagRow.style.flexWrap = "wrap";
tagRow.style.gap = "8px";
tagRow.style.alignItems = "center";
tagRow.style.marginTop = "10px";

const tagWrap = document.createElement("div");
tagWrap.className = "tag-ac-wrap";

const tagsInput = document.createElement("input");
tagsInput.type = "text";
tagsInput.className = "search-input";
tagsInput.placeholder = "Tags (comma-separated)‚Ä¶";
tagsInput.style.borderRadius = "14px";
tagsInput.style.paddingLeft = "14px";
tagsInput.style.width = "100%";
tagsInput.value = Array.isArray(linked.tags) ? linked.tags.join(", ") : "";

const suggestBox = document.createElement("div");
suggestBox.className = "tag-suggest";

tagWrap.appendChild(tagsInput);
tagWrap.appendChild(suggestBox);

const tagsSave = document.createElement("button");
tagsSave.type = "button";
tagsSave.className = "pill-btn";
tagsSave.textContent = "Save tags";

function parseTagsText(raw) {
  const parts = String(raw || "").split(",");
  const out = [];
  for (let i = 0; i < parts.length; i++) {
    const t = String(parts[i] || "").trim();
    if (t) out.push(t);
  }
  return out;
}

function collectExistingTags() {
  const seen = {};
  const out = [];
  const items = state && Array.isArray(state.items) ? state.items : [];
  for (let i = 0; i < items.length; i++) {
    const it = items[i];
    const tags = it && Array.isArray(it.tags) ? it.tags : [];
    for (let j = 0; j < tags.length; j++) {
      const t = String(tags[j] || "").trim();
      if (!t) continue;
      const key = t.toLowerCase();
      if (!seen[key]) {
        seen[key] = true;
        out.push(t);
      }
    }
  }
  out.sort(function (a, b) { return a.localeCompare(b); });
  return out;
}

let activeIndex = -1;
let activeValues = [];

function hideSuggestions() {
  suggestBox.style.display = "none";
  suggestBox.innerHTML = "";
  activeIndex = -1;
  activeValues = [];
}

function highlightActive() {
  const kids = suggestBox.querySelectorAll(".tag-suggest-item");
  for (let i = 0; i < kids.length; i++) {
    if (i === activeIndex) kids[i].classList.add("active");
    else kids[i].classList.remove("active");
  }
}

function applySuggestion(value) {
  const raw = String(tagsInput.value || "");
  const comma = raw.lastIndexOf(",");
  const head = comma === -1 ? "" : raw.slice(0, comma);
  const existing = comma === -1 ? [] : parseTagsText(head);
  existing.push(value);

  // De-dupe case-insensitive (keep first casing)
  const seen = {};
  const out = [];
  for (let i = 0; i < existing.length; i++) {
    const t = String(existing[i] || "").trim();
    if (!t) continue;
    const k = t.toLowerCase();
    if (!seen[k]) { seen[k] = true; out.push(t); }
  }

  tagsInput.value = out.join(", ") + ", ";
  hideSuggestions();
  tagsInput.focus();
}

function renderSuggestions() {
  const raw = String(tagsInput.value || "");
  const comma = raw.lastIndexOf(",");
  const tokenRaw = comma === -1 ? raw : raw.slice(comma + 1);
  const token = String(tokenRaw || "").trim().toLowerCase();

  const chosen = {};
  const chosenArr = parseTagsText(raw);
  for (let i = 0; i < chosenArr.length; i++) {
    chosen[chosenArr[i].toLowerCase()] = true;
  }

  const all = collectExistingTags();
  const matches = [];
  for (let i = 0; i < all.length; i++) {
    const t = all[i];
    const key = t.toLowerCase();
    if (chosen[key]) continue;
    if (!token || key.indexOf(token) !== -1) matches.push(t);
    if (matches.length >= 10) break;
  }

  if (!matches.length) {
    hideSuggestions();
    return;
  }

  suggestBox.innerHTML = "";
  activeValues = matches.slice();
  activeIndex = 0;

  for (let i = 0; i < matches.length; i++) {
    const v = matches[i];
    const item = document.createElement("div");
    item.className = "tag-suggest-item";
    item.textContent = v;

    // Use mousedown so the input doesn't lose focus before we apply
    item.addEventListener("mousedown", function (e) {
      e.preventDefault();
      applySuggestion(v);
    });

    suggestBox.appendChild(item);
  }

  suggestBox.style.display = "block";
  highlightActive();
}

tagsInput.addEventListener("input", function () {
  renderSuggestions();
});

tagsInput.addEventListener("focus", function () {
  renderSuggestions();
});

tagsInput.addEventListener("blur", function () {
  setTimeout(function () {
    if (!tagWrap.contains(document.activeElement)) hideSuggestions();
  }, 120);
});

tagsInput.addEventListener("keydown", function (e) {
  if (suggestBox.style.display !== "block") return;

  if (e.key === "ArrowDown") {
    e.preventDefault();
    activeIndex = Math.min(activeValues.length - 1, activeIndex + 1);
    highlightActive();
  } else if (e.key === "ArrowUp") {
    e.preventDefault();
    activeIndex = Math.max(0, activeIndex - 1);
    highlightActive();
  } else if (e.key === "Enter" || e.key === "Tab") {
    if (activeIndex >= 0 && activeIndex < activeValues.length) {
      e.preventDefault();
      applySuggestion(activeValues[activeIndex]);
    }
  } else if (e.key === "Escape") {
    e.preventDefault();
    hideSuggestions();
  }
});

tagsSave.addEventListener("click", function () {
  const next = parseTagsText(tagsInput.value || "");
  linked.tags = next;
  saveState();
  render();
  alertNice("Tags saved.");
});

tagRow.appendChild(tagWrap);
tagRow.appendChild(tagsSave);
orgGrid.appendChild(tagRow);

// Notes
const notesLabel = document.createElement("div");
notesLabel.style.marginTop = "10px";
notesLabel.style.fontSize = "12px";
notesLabel.style.color = "var(--text-muted)";
notesLabel.textContent = "Notes";
orgGrid.appendChild(notesLabel);

const notesArea = document.createElement("textarea");
notesArea.className = "settings-textarea";
notesArea.placeholder = "Add your notes‚Ä¶";
notesArea.value = typeof linked.notes === "string" ? linked.notes : "";
orgGrid.appendChild(notesArea);

const notesSave = document.createElement("button");
notesSave.type = "button";
notesSave.className = "pill-btn";
notesSave.style.marginTop = "8px";
notesSave.textContent = "Save notes";
notesSave.addEventListener("click", function () {
  linked.notes = String(notesArea.value || "");
  saveState();
  render();
  alertNice("Notes saved.");
});
orgGrid.appendChild(notesSave);

// Watched date + your rating + rewatch
const watchRow = document.createElement("div");
watchRow.className = "organise-row";
watchRow.style.flexWrap = "wrap";
watchRow.style.gap = "8px";
watchRow.style.alignItems = "center";
watchRow.style.marginTop = "12px";

const watchedInfo = document.createElement("div");
watchedInfo.style.fontSize = "12px";
watchedInfo.style.color = "var(--text-muted)";
watchedInfo.textContent = linked.watched && linked.watchedAt ? ("Watched on " + formatDateUK(linked.watchedAt)) : "Not marked as watched yet.";
watchRow.appendChild(watchedInfo);

const ratingWrap = document.createElement("div");
ratingWrap.style.display = "flex";
ratingWrap.style.alignItems = "center";
ratingWrap.style.gap = "8px";

const ratingLabel = document.createElement("span");
ratingLabel.style.fontSize = "12px";
ratingLabel.style.color = "var(--text-muted)";
ratingLabel.textContent = "Your rating:";
ratingWrap.appendChild(ratingLabel);

const ratingRange = document.createElement("input");
ratingRange.type = "range";
ratingRange.min = "0";
ratingRange.max = "10";
ratingRange.step = "0.5";
ratingRange.value = (typeof linked.userRating === "number") ? String(linked.userRating) : "0";
ratingWrap.appendChild(ratingRange);

const ratingVal = document.createElement("span");
ratingVal.style.fontSize = "12px";
ratingVal.style.color = "var(--text-muted)";
ratingVal.textContent = (typeof linked.userRating === "number") ? linked.userRating.toFixed(1) + "/10" : "‚Äî";
ratingWrap.appendChild(ratingVal);

ratingRange.addEventListener("input", function () {
  ratingVal.textContent = parseFloat(ratingRange.value).toFixed(1) + "/10";
});

const ratingSave = document.createElement("button");
ratingSave.type = "button";
ratingSave.className = "pill-btn";
ratingSave.textContent = "Save rating";
ratingSave.addEventListener("click", function () {
  if (!linked.watched) {
    alertNice("Mark as watched before saving your rating.");
    return;
  }
  linked.userRating = parseFloat(ratingRange.value);
  saveState();
  render();
  alertNice("Rating saved.");
});

ratingWrap.appendChild(ratingSave);
watchRow.appendChild(ratingWrap);

const rewatchBtn = document.createElement("button");
rewatchBtn.type = "button";
rewatchBtn.className = "pill-btn";
rewatchBtn.textContent = linked.rewatch ? "Rewatch: On" : "Rewatch: Off";
rewatchBtn.addEventListener("click", function () {
  if (!linked.watched) {
    alertNice("Mark as watched before enabling rewatch.");
    return;
  }
  linked.rewatch = !linked.rewatch;
  rewatchBtn.textContent = linked.rewatch ? "Rewatch: On" : "Rewatch: Off";
  saveState();
  render();
});
watchRow.appendChild(rewatchBtn);

orgGrid.appendChild(watchRow);

els.detailActions.appendChild(orgWrap);

          

          // Where to watch (UK)
          try {
            const providers = await fetchWatchProviders(details.id);
            const gb = providers && providers[(state.country || "GB")] ? providers[(state.country || "GB")] : null;
            const wrap = document.createElement("div");
            wrap.style.marginTop = "10px";

            const heading = document.createElement("div");
            heading.style.fontSize = "13px";
            heading.style.fontWeight = "600";
            heading.textContent = "Where to watch (" + (state.country || "GB") + ")";
            wrap.appendChild(heading);

            const providerLink = gb && gb.link ? gb.link : null;
            if (providerLink) {
              const jwBtn = document.createElement("a");
              jwBtn.className = "pill-btn";
              jwBtn.textContent = "Open on JustWatch";
              jwBtn.href = providerLink;
              jwBtn.target = "_blank";
              jwBtn.rel = "noopener noreferrer";
              jwBtn.style.display = "inline-flex";
              jwBtn.style.marginTop = "8px";
              wrap.appendChild(jwBtn);

              const hint = document.createElement("div");
              hint.style.fontSize = "12px";
              hint.style.color = "var(--text-muted)";
              hint.style.marginTop = "6px";
              hint.textContent = "Provider buttons open the JustWatch page for this film.";
              wrap.appendChild(hint);
            }

            const row = document.createElement("div");
            row.style.display = "flex";
            row.style.flexWrap = "wrap";
            row.style.gap = "8px";
            row.style.marginTop = "6px";

            function addProviderPills(list, label) {
              if (!list || !list.length) return;
              const lab = document.createElement("div");
              lab.style.width = "100%";
              lab.style.fontSize = "12px";
              lab.style.color = "var(--text-muted)";
              lab.textContent = label;
              row.appendChild(lab);
              for (let i = 0; i < list.length; i++) {
                const p = list[i];
                const pill = document.createElement("span");
                pill.className = "detail-chip";
                if (providerLink) {
                  pill.style.cursor = "pointer";
                  pill.setAttribute("role", "link");
                  pill.setAttribute("tabindex", "0");
                  pill.addEventListener("click", function () {
                    window.open(providerLink, "_blank", "noopener");
                  });
                  pill.addEventListener("keydown", function (e) {
                    if (e.key === "Enter" || e.key === " ") {
                      e.preventDefault();
                      window.open(providerLink, "_blank", "noopener");
                    }
                  });
                }
                pill.style.display = "inline-flex";
                pill.style.alignItems = "center";
                pill.style.gap = "6px";
                if (p.logo_path) {
                  const img = document.createElement("img");
                  img.src = "https://image.tmdb.org/t/p/w45" + p.logo_path;
                  img.alt = p.provider_name;
                  img.style.width = "18px";
                  img.style.height = "18px";
                  img.style.borderRadius = "4px";
                  row.appendChild(pill);
                  pill.appendChild(img);
                }
                const text = document.createElement("span");
                text.textContent = p.provider_name;
                pill.appendChild(text);
                row.appendChild(pill);
              }
            }

            if (gb) {
              addProviderPills(gb.flatrate, "Stream");
              addProviderPills(gb.rent, "Rent");
              addProviderPills(gb.buy, "Buy");
              if ((!gb.flatrate || !gb.flatrate.length) && (!gb.rent || !gb.rent.length) && (!gb.buy || !gb.buy.length)) {
                const none = document.createElement("div");
                none.style.fontSize = "12px";
                none.style.color = "var(--text-muted)";
                none.textContent = "No provider data available from TMDB for your selected country.";
                row.appendChild(none);
              }
            } else {
              const none = document.createElement("div");
              none.style.fontSize = "12px";
              none.style.color = "var(--text-muted)";
              none.textContent = "No provider data available from TMDB for your selected country.";
              row.appendChild(none);
            }

            wrap.appendChild(row);
            els.detailLinks.appendChild(wrap);
          } catch (e) {
            // ignore provider failures
          }

          const videos = details.videos && details.videos.results
            ? details.videos.results
            : [];
          let trailer = null;
          for (let i = 0; i < videos.length; i++) {
            const v = videos[i];
            if (v.site === "YouTube" && v.type === "Trailer" && v.official) {
              trailer = v;
              break;
            }
          }
          if (!trailer) {
            for (let i = 0; i < videos.length; i++) {
              const v = videos[i];
              if (v.site === "YouTube" && v.type === "Trailer") {
                trailer = v;
                break;
              }
            }
          }

          if (trailer) {
            const link = document.createElement("a");
            link.className = "detail-link";
            link.href = "https://www.youtube.com/watch?v=" + trailer.key;
            link.target = "_blank";
            link.rel = "noopener noreferrer";
            link.textContent = "Watch trailer on YouTube";
            els.detailLinks.appendChild(link);
          }
        } catch (err) {
          console.error(err);
          els.detailTitle.textContent = "Couldn‚Äôt load details";
          els.detailOverview.textContent =
            "There was a problem fetching extra information for this film.";
        }
      }


      function openMenu() {
        if (!els.menuOverlay) return;
        els.menuOverlay.classList.remove("hidden");
        els.menuOverlay.setAttribute("aria-hidden", "false");
        updateMenuActiveState();
        renderMenuPinnedLists();
      }

      function closeMenu() {
        if (!els.menuOverlay) return;
        els.menuOverlay.classList.add("hidden");
        els.menuOverlay.setAttribute("aria-hidden", "true");
      }

      function updateMenuActiveState() {
        if (!els.menuItems) return;
        for (let i = 0; i < els.menuItems.length; i++) {
          const b = els.menuItems[i];
          b.classList.toggle("active", b.dataset.tab === state.activeTab);
        }
      }

      function switchToTab(tab) {
        if (!tab) return;
        if (tab === state.activeTab) {
          render();
          return;
        }
        state.activeTab = tab;
        state.searchTerm = "";
        if (els.searchInput) els.searchInput.value = "";
        if (tab === "for-you") {
          loadForYouRecommendations();
        } else if (tab === "discover") {
          state.discoverMode = "default";
          state.discoverSeedTitle = "";
          loadPopularForDiscover();
        } else if (tab === "radar") {
          loadRadarUpcoming();
        } else {
          if (getMoodKey() !== "any" && (tab === "watchlist" || tab === "watched" || tab === "rewatch")) {
            ensureDetailsForLocalTab();
          } else {
            render();
          }
        }
      }


      function buildExportPayload() {
        // Only store user data (not API keys or cached TMDB details)
        const payload = {
          app: "ReelQuest",
          version: "v1",
          exportedAt: new Date().toISOString(),
          data: {
            items: state.items,
            lists: state.lists,
            listsUi: state.listsUi,
            favouriteGenres: state.favouriteGenres,
            filters: state.filters,
            sortBy: state.sortBy,
            minRating: state.minRating,
            theme: state.theme,
            country: state.country,
            includeTv: state.includeTv,
            mood: state.mood
          }
        };
        return payload;
      }

      function exportDataToFile() {
        try {
          const payload = buildExportPayload();
          const json = JSON.stringify(payload, null, 2);
          const blob = new Blob([json], { type: "application/json" });
          const url = URL.createObjectURL(blob);

          const stamp = new Date();
          const yyyy = stamp.getFullYear();
          const mm = String(stamp.getMonth() + 1).padStart(2, "0");
          const dd = String(stamp.getDate()).padStart(2, "0");
          const filename = "reelquest-backup-" + yyyy + "-" + mm + "-" + dd + ".json";

          const a = document.createElement("a");
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);

          setTimeout(function () { URL.revokeObjectURL(url); }, 1000);
          const listCount = Array.isArray(state.lists) ? state.lists.length : 0;
          const filmCount = Array.isArray(state.items) ? state.items.length : 0;
          alertNice("Export complete. Saved " + filmCount + " film record(s) and " + listCount + " list(s) to your device.");
        } catch (e) {
          console.error(e);
          alertNice("Sorry ‚Äî we couldn‚Äôt export your data.");
        }
      }

      function normaliseImportedItems(items) {
  if (!Array.isArray(items)) return [];
  const clean = [];
  for (let i = 0; i < items.length; i++) {
    const it = items[i];
    if (!it || typeof it !== "object") continue;

    const tmdbId = toTmdbId(it.tmdbId);
    const title = typeof it.title === "string" ? it.title : "";
    if (!tmdbId || !title) continue;

    const year = typeof it.year === "string" ? it.year : "";
    const posterPath = typeof it.posterPath === "string" ? it.posterPath : null;
    const rating = typeof it.rating === "number" ? it.rating : null;

    const mediaType = (it.mediaType === "tv" || it.mediaType === "movie") ? it.mediaType : "movie";

    const inWatchlist = !!it.inWatchlist;
    const watched = !!it.watched;

    const notes = typeof it.notes === "string" ? it.notes : "";
    const tags = Array.isArray(it.tags)
      ? it.tags.filter(function (t) { return typeof t === "string" && t.trim(); }).map(function (t) { return t.trim(); })
      : [];

    const priority = (it.priority === "high" || it.priority === "medium" || it.priority === "low") ? it.priority : "medium";
    const watchedAt = (typeof it.watchedAt === "number") ? it.watchedAt : (watched ? Date.now() : null);
    const userRating = (typeof it.userRating === "number") ? it.userRating : null;
    const rewatch = !!it.rewatch;
    const status = (inWatchlist && !watched)
      ? normaliseWatchStatus((typeof it.status !== "undefined") ? it.status : it.progressStatus)
      : null;

    clean.push({
      id: typeof it.id === "string" ? it.id : safeId(),
      tmdbId: tmdbId,
      mediaType: mediaType,
      title: title,
      year: year,
      posterPath: posterPath,
      rating: rating,
      inWatchlist: inWatchlist,
      watched: watched,
      watchedAt: watchedAt,
      userRating: userRating,
      rewatch: rewatch,
      status: status,
      priority: priority,
      tags: tags,
      notes: notes,
      createdAt: typeof it.createdAt === "number" ? it.createdAt : (typeof it.addedAt === "number" ? it.addedAt : Date.now()),
      addedAt: typeof it.addedAt === "number" ? it.addedAt : (typeof it.createdAt === "number" ? it.createdAt : Date.now())
    });
  }
  return clean;
}

      function normaliseImportedLists(lists) {
  if (!Array.isArray(lists)) return [];
  const clean = [];
  for (let i = 0; i < lists.length; i++) {
    const l = lists[i];
    if (!l || typeof l !== "object") continue;

    const name = typeof l.name === "string" ? l.name.trim() : "";
    if (!name) continue;

    const type = l.type === "smart" ? "smart" : "manual";
    const pinned = !!l.pinned;
    const description = typeof l.description === "string" ? l.description : "";

    const sortMode =
      typeof l.sortMode === "string" &&
      (l.sortMode === "custom" || l.sortMode === "rating" || l.sortMode === "year" || l.sortMode === "title")
        ? l.sortMode
        : "custom";

    const customOrder = Array.isArray(l.customOrder)
      ? l.customOrder.filter(function (x) { return typeof x === "number" || typeof x === "string"; })
      : [];

    const smartRules = l.smartRules && typeof l.smartRules === "object" ? l.smartRules : null;
    const cachedResults = Array.isArray(l.cachedResults) ? l.cachedResults : [];
    const cachedAt = typeof l.cachedAt === "number" ? l.cachedAt : 0;

    const entriesRaw = Array.isArray(l.entries) ? l.entries : [];
    const entries = [];
    for (let j = 0; j < entriesRaw.length; j++) {
      const e = entriesRaw[j];
      if (!e || typeof e !== "object") continue;
      const tmdbId = toTmdbId(e.tmdbId);
      const title = typeof e.title === "string" ? e.title : "";
      if (!tmdbId || !title) continue;
      const mediaType = (e.mediaType === "tv" || e.mediaType === "movie") ? e.mediaType : "movie";
      entries.push({
        tmdbId: tmdbId,
        mediaType: mediaType,
        title: title,
        year: typeof e.year === "string" ? e.year : "",
        posterPath: typeof e.posterPath === "string" ? e.posterPath : null,
        rating: typeof e.rating === "number" ? e.rating : null,
        addedAt: typeof e.addedAt === "number" ? e.addedAt : Date.now()
      });
    }

    clean.push({
      id: typeof l.id === "string" ? l.id : safeId(),
      type: type,
      name: name,
      description: description,
      pinned: pinned,
      sortMode: sortMode,
      customOrder: customOrder,
      smartRules: smartRules,
      cachedResults: cachedResults,
      cachedAt: cachedAt,
      entries: entries,
      createdAt: typeof l.createdAt === "number" ? l.createdAt : Date.now()
    });
  }
  return clean;
}

      function applyImportedData(imported) {
        const data = imported && imported.data ? imported.data : imported;

        const items = normaliseImportedItems(data && data.items ? data.items : []);
        const lists = normaliseImportedLists(data && data.lists ? data.lists : []);
        const listsUi = data && data.listsUi && typeof data.listsUi === "object" ? data.listsUi : null;
        const filters = data && data.filters && typeof data.filters === "object" ? data.filters : null;
        const country = data && typeof data.country === "string" && data.country.length === 2 ? data.country.toUpperCase() : null;
        const favouriteGenres = Array.isArray(data && data.favouriteGenres) ? data.favouriteGenres : [];
        const sortBy = data && typeof data.sortBy === "string" ? data.sortBy : state.sortBy;
        const minRating = data && typeof data.minRating === "number" ? data.minRating : state.minRating;
        const theme = data && (data.theme === "light" || data.theme === "dark") ? data.theme : state.theme;
        const includeTv = data && typeof data.includeTv === "boolean" ? data.includeTv : state.includeTv;
        const mood = data && typeof data.mood === "string" && MOODS[data.mood] ? data.mood : state.mood;

        state.items = items;
        state.lists = lists;
        state.listsUi = {
          mode: (listsUi && listsUi.mode === "detail") ? "detail" : "index",
          activeListId: (listsUi && typeof listsUi.activeListId === "string") ? listsUi.activeListId : null,
          reorderMode: (listsUi && listsUi.reorderMode) ? true : false
        };
        state.country = country || state.country || "GB";

        state.filters = {
          minYear: (filters && typeof filters.minYear === "number") ? filters.minYear : 0,
          hideWatched: filters ? !!filters.hideWatched : false,
          hideWatchlist: filters ? !!filters.hideWatchlist : false,
          excludedGenres: (filters && Array.isArray(filters.excludedGenres)) ? filters.excludedGenres : []
        };
        state.favouriteGenres = favouriteGenres;
        state.sortBy = sortBy;
        state.minRating = minRating;
        state.theme = theme;
        state.includeTv = includeTv;
        state.mood = mood;

        // Clear caches that could be stale
        state.detailsCache = {};

        saveState();
        applyTheme();

        // Refresh current tab content
        if (state.activeTab === "for-you") {
          loadForYouRecommendations();
        } else if (state.activeTab === "discover") {
          loadPopularForDiscover();
        } else {
          render();
        }
      }



function mergeImportedData(imported) {
  const data = imported && imported.data ? imported.data : imported;

  const incomingItems = normaliseImportedItems(data && data.items ? data.items : []);
  const incomingLists = normaliseImportedLists(data && data.lists ? data.lists : []);

  // Merge items by (mediaType + tmdbId)
  const index = {};
  for (let i = 0; i < state.items.length; i++) {
    const it = state.items[i];
    index[entryKey(it.mediaType || "movie", it.tmdbId)] = it;
  }

  for (let i = 0; i < incomingItems.length; i++) {
    const inc = incomingItems[i];
    const key = entryKey(inc.mediaType || "movie", inc.tmdbId);
    const existing = index[key];

    if (!existing) {
      state.items.push(inc);
      index[key] = inc;
      continue;
    }

    // Merge workflow flags (be conservative: keep anything already set)
    existing.inWatchlist = !!(existing.inWatchlist || inc.inWatchlist);
    existing.watched = !!(existing.watched || inc.watched);
    if (!existing.watchedAt && inc.watchedAt) existing.watchedAt = inc.watchedAt;

    existing.rewatch = !!(existing.rewatch || inc.rewatch);

    if (existing.userRating === null && inc.userRating !== null) existing.userRating = inc.userRating;
    if (existing.priority === "medium" && inc.priority && inc.priority !== "medium") existing.priority = inc.priority;

    // Tags union
    const tags = {};
    const outTags = [];
    const a = Array.isArray(existing.tags) ? existing.tags : [];
    const b = Array.isArray(inc.tags) ? inc.tags : [];
    for (let t = 0; t < a.length; t++) { const v = String(a[t]); if (!tags[v]) { tags[v] = true; outTags.push(v); } }
    for (let t = 0; t < b.length; t++) { const v = String(b[t]); if (!tags[v]) { tags[v] = true; outTags.push(v); } }
    existing.tags = outTags;

    // Notes: keep existing, append imported if different
    const en = (existing.notes || "").trim();
    const inN = (inc.notes || "").trim();
    if (!en && inN) existing.notes = inN;
    else if (en && inN && en !== inN) existing.notes = en + "\n\n‚Äî Imported note ‚Äî\n" + inN;

    // Keep basic metadata if missing
    if (!existing.title && inc.title) existing.title = inc.title;
    if (!existing.year && inc.year) existing.year = inc.year;
    if (!existing.posterPath && inc.posterPath) existing.posterPath = inc.posterPath;
    if ((existing.rating === null || existing.rating === undefined) && typeof inc.rating === "number") existing.rating = inc.rating;
  }

  // Merge lists
  function findListMatch(inList) {
    for (let i = 0; i < state.lists.length; i++) {
      if (state.lists[i].id === inList.id) return state.lists[i];
    }
    const name = (inList.name || "").trim().toLowerCase();
    for (let i = 0; i < state.lists.length; i++) {
      const ex = state.lists[i];
      if ((ex.name || "").trim().toLowerCase() === name && ex.type === inList.type) return ex;
    }
    return null;
  }

  for (let i = 0; i < incomingLists.length; i++) {
    const inList = incomingLists[i];
    const match = findListMatch(inList);

    if (!match) {
      // Add new list with safe id and unique name
      inList.id = safeId();
      inList.name = ensureUniqueListName(inList.name || "Untitled list");
      inList.pinned = false;
      ensureCustomOrder(inList);
      state.lists.push(inList);
      continue;
    }

    // Merge description/pin cautiously
    if (!match.description && inList.description) match.description = inList.description;

    if (match.type === "manual" && inList.type === "manual") {
      mergeListEntries(match, inList);
    }
  }

  // Merge preferences (non-destructive)
  const filters = data && data.filters && typeof data.filters === "object" ? data.filters : null;

  if (filters && typeof state.filters === "object") {
    if (!state.filters.minYear && typeof filters.minYear === "number") state.filters.minYear = filters.minYear;
    if (!state.filters.hideWatched && filters.hideWatched) state.filters.hideWatched = true;
    if (!state.filters.hideWatchlist && filters.hideWatchlist) state.filters.hideWatchlist = true;

    // excludedGenres union
    const ex = Array.isArray(state.filters.excludedGenres) ? state.filters.excludedGenres : [];
    const incEx = (filters && Array.isArray(filters.excludedGenres)) ? filters.excludedGenres : [];
    const map = {};
    const out = [];
    for (let i = 0; i < ex.length; i++) { const v = String(ex[i]); if (!map[v]) { map[v] = true; out.push(v); } }
    for (let i = 0; i < incEx.length; i++) { const v = String(incEx[i]); if (!map[v]) { map[v] = true; out.push(v); } }
    state.filters.excludedGenres = out;
  }

  const fav = Array.isArray(state.favouriteGenres) ? state.favouriteGenres : [];
  const incFav = Array.isArray(data && data.favouriteGenres) ? data.favouriteGenres : [];
  if (incFav.length) {
    const map = {};
    const out = [];
    for (let i = 0; i < fav.length; i++) { const v = String(fav[i]); if (!map[v]) { map[v] = true; out.push(v); } }
    for (let i = 0; i < incFav.length; i++) { const v = String(incFav[i]); if (!map[v]) { map[v] = true; out.push(v); } }
    state.favouriteGenres = out;
  }

  // Country/includeTv: only apply if missing
  if ((!state.country || state.country.length !== 2) && data && typeof data.country === "string" && data.country.length === 2) {
    state.country = data.country.toUpperCase();
  }
  if (typeof state.includeTv !== "boolean" && data && typeof data.includeTv === "boolean") {
    state.includeTv = data.includeTv;
  }

  // Clear caches that could be stale
  state.detailsCache = {};

  saveState();
  applyTheme();
  render();
}



      function handleImportFile(file) {
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function () {
    try {
      const text = String(reader.result || "");
      const parsed = JSON.parse(text);

      const looksLikeReelQuest =
        parsed && typeof parsed === "object" &&
        (parsed.app === "ReelQuest" || parsed.version || parsed.data);

      if (!looksLikeReelQuest) {
        const ok = window.confirm(
          "This file doesn‚Äôt look like a ReelQuest backup. Try importing anyway?"
        );
        if (!ok) return;
      }

      const wantMerge = window.confirm("How do you want to import this backup?\n\nOK = Merge into your existing data\nCancel = Replace everything");

      if (wantMerge) {
        mergeImportedData(parsed);
        toast("Import merged.");
      } else {
        const confirmReplace = window.confirm(
          "Replace your current watchlist, watched list, lists and preferences with this backup?"
        );
        if (!confirmReplace) return;
        applyImportedData(parsed);
        toast("Import complete.");
      }
    } catch (err) {
      console.error(err);
      alertNice("Sorry ‚Äî we couldn‚Äôt import that file.");
    }
  };
  reader.onerror = function () {
    alertNice("Sorry ‚Äî we couldn‚Äôt read that file.");
  };
  reader.readAsText(file);
}

      // PWA (optional): service worker + install hint
async function registerServiceWorker() {
  try {
    if (!("serviceWorker" in navigator)) return;
    if (location.protocol !== "https:" && location.hostname !== "localhost") return;
    await navigator.serviceWorker.register("./sw.js");
  } catch (e) {}
}

async function unregisterServiceWorkersAndClearCaches() {
  try {
    if ("serviceWorker" in navigator) {
      const regs = await navigator.serviceWorker.getRegistrations();
      for (let i = 0; i < regs.length; i++) {
        try { await regs[i].unregister(); } catch (e) {}
      }
    }
    if (typeof caches !== "undefined" && caches.keys) {
      const keys = await caches.keys();
      for (let i = 0; i < keys.length; i++) {
        try { await caches.delete(keys[i]); } catch (e) {}
      }
    }
  } catch (e) {}
}

function isIos() {
  return /iPhone|iPad|iPod/i.test(navigator.userAgent || "");
}

function isStandalone() {
  return (window.navigator && window.navigator.standalone) ? true : (window.matchMedia && window.matchMedia("(display-mode: standalone)").matches);
}

function showInstallHint() {
  if (isIos() && !isStandalone()) {
    toast("On iPhone: tap Share, then ‚ÄòAdd to Home Screen‚Äô.");
  } else {
    toast("Install isn‚Äôt available on this browser right now.");
  }
}

function init() {
        try {
          const qs = new URLSearchParams(location.search || "");
          if (qs.get("nosw") === "1") {
            unregisterServiceWorkersAndClearCaches();
          } else {
            registerServiceWorker();
          }
        } catch (e) {}
        els = {
          tabButtons: document.querySelectorAll(".tab-btn"),
          sectionTitle: document.getElementById("section-title"),
          sectionSubtitle: document.getElementById("section-subtitle"),
          searchForm: document.getElementById("search-form"),
          searchInput: document.getElementById("search-input"),
          message: document.getElementById("message"),
          grid: document.getElementById("card-grid"),
          settingsPanel: document.getElementById("settings-panel"),
          listsPanel: document.getElementById("lists-panel"),
          accountPanel: document.getElementById("account-panel"),
          debug: document.getElementById("debug"),
          controlsBar: document.getElementById("controls-bar"),
          sortSelect: document.getElementById("sort-select"),
          ratingFilterSelect: document.getElementById("rating-filter-select"),
          moodSelect: document.getElementById("mood-select"),
          streamingSelect: document.getElementById("streaming-select"),
          listActions: document.getElementById("list-actions"),
          importInput: document.getElementById("import-input"),
          detailOverlay: document.getElementById("detail-overlay"),
          detailClose: document.getElementById("detail-close"),
          detailTitle: document.getElementById("detail-title"),
          detailMeta: document.getElementById("detail-meta"),
          detailPoster: document.getElementById("detail-poster"),
          detailOverview: document.getElementById("detail-overview"),
          detailChips: document.getElementById("detail-chips"),
          detailActions: document.getElementById("detail-actions"),
          detailLinks: document.getElementById("detail-links"),
          themeToggle: document.getElementById("theme-toggle"),
          settingsToggle: document.getElementById("settings-toggle"),
          menuToggle: document.getElementById("menu-toggle"),
          menuOverlay: document.getElementById("menu-overlay"),
          menuClose: document.getElementById("menu-close"),
          menuItems: document.querySelectorAll(".menu-item"),
          brandHome: document.getElementById("brand-home")
        };

        loadState();
        migrateWatchProgressStatuses();
        migrateWatchlistWatchedInvariant();
        migrateItemsMediaType();
        handleIncomingSharedList();
        migrateTmdbIdsToNumbers();
        migrateItemsMediaType();
        applyTheme();
        render();

        // Initial load for the starting tab
        if (state.activeTab === "discover") {
          loadPopularForDiscover();
        } else if (state.activeTab === "for-you") {
          loadForYouRecommendations();
        } else if (state.activeTab === "radar") {
          loadRadarUpcoming();
        }

        if (state.activeTab === "for-you" && state.favouriteGenres.length) {
          loadForYouRecommendations();
        }

        for (let i = 0; i < els.tabButtons.length; i++) {
          els.tabButtons[i].addEventListener("click", handleTabClick);
        }

        if (els.brandHome) {
          els.brandHome.addEventListener("click", function () {
            if (state.activeTab !== "for-you") {
              try { closeDetail(); } catch (e) {}
              try { closeMenu(); } catch (e) {}
              switchToTab("for-you");
            } else {
              try {
                window.scrollTo({ top: 0, behavior: "smooth" });
              } catch (e) {
                window.scrollTo(0, 0);
              }
            }
          });
        }


        if (els.searchInput) els.searchInput.addEventListener("input", handleSearchInput);
        if (els.searchForm) els.searchForm.addEventListener("submit", handleSearchSubmit);
        if (els.sortSelect) els.sortSelect.addEventListener("change", handleSortChange);
        if (els.ratingFilterSelect) els.ratingFilterSelect.addEventListener("change", handleRatingFilterChange);
        if (els.moodSelect) els.moodSelect.addEventListener("change", handleMoodChange);
        if (els.streamingSelect) els.streamingSelect.addEventListener("change", handleStreamingModeChange);

        if (els.importInput) {
          els.importInput.addEventListener("change", function (e) {
            const files = e.target && e.target.files ? e.target.files : null;
            if (files && files[0]) {
              handleImportFile(files[0]);
            }
          });
        }

        if (els.themeToggle) {
          els.themeToggle.addEventListener("click", toggleTheme);
        }

        if (els.settingsToggle) {
          els.settingsToggle.addEventListener("click", function () {
            switchToTab("settings");
          });
        }

        if (els.menuToggle) {
          els.menuToggle.addEventListener("click", function () {
            openMenu();
          });
        }
        if (els.menuClose) {
          els.menuClose.addEventListener("click", function () {
            closeMenu();
          });
        }
        if (els.menuOverlay) {
          els.menuOverlay.addEventListener("click", function (e) {
            if (e.target === els.menuOverlay) {
              closeMenu();
            }
          });
        }
        if (els.menuItems) {
          for (let i = 0; i < els.menuItems.length; i++) {
            els.menuItems[i].addEventListener("click", function (e) {
              const tab = e.currentTarget.dataset.tab;
              closeMenu();
              switchToTab(tab);
            });
          }
        }

        if (els.detailClose) {
          els.detailClose.addEventListener("click", closeDetail);
        }
        if (els.detailOverlay) {
          els.detailOverlay.addEventListener("click", function (e) {
            if (e.target === els.detailOverlay) {
              closeDetail();
            }
          });
        }

        updateDebug("ReelQuest ready (JS initialised)");
      }

      document.addEventListener("DOMContentLoaded", init);
    })();
</script>
<div aria-atomic="true" aria-live="polite" id="toast-host"></div>
</body>
</html>
